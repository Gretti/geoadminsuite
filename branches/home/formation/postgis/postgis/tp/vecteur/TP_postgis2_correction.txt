1°) Verifier la validité des geometries des 3 tables crees. Identifier les objets
invalides (identifiant, autre)
select distinct st_isvalid(the_geom) from lake;
select distinct st_isvalid(the_geom) from street;
select distinct st_isvalid(the_geom) from river;

2°) Identifier les raisons de l'invalidité.
cf. sortie affichage: qu'est-ce que ca veut dire.

3°) Visualiser les geometries invalides, utilisation de OpenJump pour les caractériser.
    Utiliser OpenJump pour trouver les geometries invalides
Ouvrir OpenJump, charger la couche, identifier les objets invalides
                 Utiliser le menu QA pour valider la couche: choix des criteres
    
4°) Essayer de corriger les geometries invalides avec PostGIS:
    st_makeValid(geom)

(avant la version 2.0 de postgis et st_makeValid() , il est possible d'utiliser la fonction
buffer pour essayer de corriger des polygones invalides: 
    st_buffer(the_geom, 0)
)
    
select isvalid(buffer(st_makeValid, 0.0)) from lake where gid = 20; 
update lake set the_geom = st_multi(st_makeValid(the_geom)) where gid = 20;
    
    explosion d'une collection en objets simples (generate_series, st_dump)
    
-- avec generate series: iteration sur le nombre d'objets contenus
-- dans la geometrie
select gid, st_geometryType(
    st_geometryN(
        the_geom, generate_series(
            1, 
            numgeometries(the_geom)
        )
    )
 ) from lake; 

-- avec st_dump (set-returning function: renvoie un ensemble de ligne pour un record donné)
select gid, st_geometryType((st_dump(the_geom)).geom) from lake;    
    
Reconstruction d'une collection a partir d'objets simples.
    

5°) Realiser l'union de tous les lacs, utiliser deux methodes differentes:
st_collect + st_buffer, st_union.
Comparer la difference: activer le timing dans la console psql en tapant '\timing' dans le prompt psql.

select st_union(the_geom) from lake;
select st_buffer(st_collect(the_geom), 0.0) from lake;    



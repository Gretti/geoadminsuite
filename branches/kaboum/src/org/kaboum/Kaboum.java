/*
 *
 * Main class of the Kaboum project. Kaboum is a frontend
 * to mapserver (http://mapserver.gis.umn.edu)
 *
 * Copyright (C) 2000-2003 Jerome Gasperi
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 
 */
package org.kaboum;

import java.applet.*;
import java.net.URL;
import java.awt.*;
import java.awt.event.*;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import java.util.Hashtable;
import java.util.Enumeration;
import java.util.StringTokenizer;

import java.util.Vector;
import netscape.javascript.*;

import org.kaboum.util.KaboumExtent;

import org.kaboum.util.KaboumUtil;
import org.kaboum.util.KaboumMapServerTools;
import org.kaboum.util.KaboumPrecisionModel;
import org.kaboum.util.KaboumWKTReader;
import org.kaboum.util.KaboumCoordinate;
import org.kaboum.util.KaboumFeatureServerTools;
import org.kaboum.util.KaboumActiveGeometryParameters;

import org.kaboum.geom.KaboumGGDIndex;
import org.kaboum.geom.KaboumGeometryDisplayDescriptor;
import org.kaboum.geom.KaboumGeometry;
import org.kaboum.geom.KaboumGeometryPropertiesDescriptor;
import org.kaboum.geom.KaboumGeometryGlobalDescriptor;
import org.kaboum.util.KaboumWKTWriter;

/**
 *
 * Kaboum (Kaboum is Another Builder Of Usefull Maps) was
 * originally developped in order to navigate through maps
 * generated by MapServer (http://mapserver.gis.umn.edu).
 * The aim of the project is to give a powerfull tool that
 * allow interactive browsing on maps (like navigation, layers
 * query, online digitalization etc...)
 *
 * @author Jerome Gasperi aka jrom
 *
 */
public class Kaboum extends Applet {
    //
    // Final and static constants
    //
    
    /** Current version */
    private final String K_VERSION = "Kaboum v5.5";
    
    /** Current package */
    public static String pkName = "org.kaboum.";
    
    /** New line */
    public static String K_NEWLINE = System.getProperty("line.separator");
    
    /** TRUE */
    public static String TRUE = "TRUE";
    
    /** FALSE */
    public static String FALSE = "FALSE";
    
    /** K_NEW_GEOMETRY declaration (was final but can be change now)
     * it is now (13/09/2005) a String to cope with more id types for kaboum geometries
     */
    public static String K_NEW_GEOMETRY = "K_NEW_GEOMETRY";
    
    /** kaboum server mode to keep in kaboum only objects from the current extent */
    public static String MODE_LIVE = "LIVE";
    
    /** kaboum server mode to keep in kaboum only objects from the current extent */
    public static String MODE_KEEP = "KEEP";
    
    /** kaboum server mode to keep in kaboum only objects from the current extent */
    public static String MODE_KEEP_CACHE = "KEEP_CACHE";
    
    //
    // Applet specific variables
    //
    
    /** Window applet size */
    public Dimension screenSize;
    
    /** Double buffering (Image) */
    public Image offScreenImage;
    
    /** Double buffering (Graphic) */
    public Graphics offScreenGraphics;
    
    /** Applet graphical context */
    private Graphics g;
    
    /** Set the system in standby mode */
    public boolean systemStandby = false;
    
    /** Liveconnect activated  */
    public boolean isJavascriptEnabled = false;
    
    /** Use status bar for message or no  */
    public boolean sendPositionCoordinatesToJS = false;
    
    /** True during map loading */
    public boolean busy = true;
    
    /** Map image */
    public Image map;
    
    /** Busy Image (i.e. Image showed during map loading) */
    public Image busyImg = null;
    
    /** Cursor type */
    public String cursorValue = "DEFAULT";
    
    /** Browser window reference */
    public JSObject window;
    
    /** Image or Applet reference view */
    public boolean ref_is_applet = true;
    
    /** Lang */
    public KaboumLang defaultLang;
    
    /** Background color */
    private Color bgColor = Color.white;
    
    
    //
    // Mapserver and FeatureServer specific variables
    //
    
    /** KaboumMapServerTools reference */
    public KaboumMapServerTools mapServerTools;
    
    /** KaboumFeatureServerTools reference: the object dealing with exchanging feature objects
     * and commands between client and server.
     */
    public KaboumFeatureServerTools featureServerTools;
    
    /** Precision Model reference */
    private KaboumPrecisionModel pm;
    
    
    //
    // Geometrys specific variables
    //
    
    /** Indexed list of geometricals object */
    public KaboumGGDIndex GGDIndex = new KaboumGGDIndex(this);
    
    /** Geo objects classes list */
    public Hashtable geometryPDHash = new Hashtable();
    
    /** Display descriptor list */
    public Hashtable geometryDDHash = new Hashtable();
    
    /** Current geo Object */
    public KaboumGeometryGlobalDescriptor activeGGD = null;
    
    
    /** Default display descriptor */
    public KaboumGeometryDisplayDescriptor defaultDD = null;
    
    /** Current display descriptor */
    public KaboumGeometryDisplayDescriptor currentDD = null;
    
    
    /** Default object properties */
    public KaboumGeometryPropertiesDescriptor defaultPD = null;
    
    /** Current object properties */
    public KaboumGeometryPropertiesDescriptor currentPD = null;
    
    
    /** Current surface */
    public double currentSurface = -1;
    
    /** Current perimeter */
    public double currentPerimeter = -1;
    
    
    //
    // OpMode specific
    //
    
    /** OpMode list */
    private Hashtable opModeHash = new Hashtable();
    
    /** List of the OpMode properties */
    public Hashtable opModePropertiesHash = new Hashtable();
    
    /** Current active opMode */
    public KaboumOpMode currentOpMode = null;
    
    /** Current command (state of the applet) */
    public String currentCommand = "ZOOMIN";
    
    /** X center of pan */
    public int panCenterX = 0;
    
    /** Y center of pan */
    public int panCenterY = 0;
    
    /** True if pan is on */
    private boolean panStatus = false;
    
    /** True if zoom is on */
    private boolean zoomStatus = false;
    
    /** APPLET NAME */
    private String appletName = "kaboum";
    
    /** INDICATE SOURCE APPLET */
    private boolean showAppletName = false;
    
    /** This object is used for topological operation */
    public KaboumActiveGeometryParameters agp = new KaboumActiveGeometryParameters(this);
    
    /** the KaboumOpModeStatus object used by Edition drawers to control their state */
    public KaboumOpModeStatus opModeStatus;
    
    /** a hash storing all initialization properties. Key is the property name, value is the string value
     * (see doc)
     */
    public Hashtable kaboumProperties = null;
    /** the mapExtent as read from the init property */
    public KaboumExtent mapExtent;
    /** the restricted extent as read from the init property */
    public KaboumExtent restrictedExtent;
    
    /** the userMetadata string object to pass to the server at each request
     * (only used if a KaboumServer url is configure. ) See JS doc for method to 
     * set this value with Javascript.
     * See KaboumServer doc to use this parameter on the server side.
     */
    public String userMetadata = "";

    /**
     *
     * Applet initialisation.
     * Get the paramater from input html.
     *
     */
    public void init() {
        kaboumProperties = new Hashtable();
        // Initialize the KaboumUtil class with the applet's codebase to allow utils
        // to generate absolute URLs from relative URL, thus avoiding common configuration
        // mistakes
        KaboumUtil.setAppletCodeBase(this.getCodeBase());
        // Variables declaration
        // Version
        System.out.println(K_VERSION);
        
        // License
        System.out.println("Kaboum is a frontend to mapserver (http://mapserver.gis.umn.edu)\n\nCopyright (C) 2000-2003 Jerome Gasperi aka jrom\n\n");

        ///////////////// loading applet parameters /////////////////////////////
        initParam("KABOUM_USE_LIVECONNECT", null);
        // LiveConnect activated : gets browser window
        if (isJavascriptEnabled) {
            try {
                this.window = JSObject.getWindow(this);
            } catch (Exception je) {
                System.err.println("JS object error: " + je.getMessage());
                this.isJavascriptEnabled = false;
            }
        }

        //
        // Following are the inner properties of Kaboum applet
        // Applet Name
        if (getParameter("KABOUM_APPLET_NAME") != null) {
            initParam("KABOUM_APPLET_NAME", null);
        }
        initParam("KABOUM_SHOW_APPLET_NAME_IN_RESULT", null);
        initParam("KABOUM_DEBUG_MODE", null);
        initParam("MAPFILE_UNITS", null);
        initParam("KABOUM_REFERENCE_MAP_IS_APPLET", null);
        initParam("KABOUM_BACKGROUND_COLOR", null);
        KaboumUtil.debug("JAVASCRIPT ENABLED : " + this.isJavascriptEnabled);
        initParam("KABOUM_SEND_POSITION_COORDINATES_TO_JS", null);
        KaboumUtil.debug("KABOUM_SEND_POSITION_COORDINATES_TO_JS : " + this.sendPositionCoordinatesToJS);
        initParam("KABOUM_BUSY_IMAGE_URL", null);
        initParam("KABOUM_LANG", null);
        initParam("GEOMETRY_DEFAULT_ID", null);
        initParam("MAPFILE_EXTENT", null);
        initParam("KABOUM_MAXIMUM_EXTENT", null);
        initParam("KABOUM_MAPSERVER_CGI_URL", null);
        initParam("MAPFILE_PATH", null);
        initParam("KABOUM_HISTORY_SIZE", null);
        initParam("LAYERS", null);
        initParam("QUERY_LAYERS", null);
        initParam("KABOUM_MAXIMUM_SCALE", null);
        initParam("KABOUM_USE_IMAGE_CACHING", null);
        
        initParam("KABOUM_IMAGE_TYPE", null);
        initParam("KABOUM_IMAGE_QUALITY", null);
        initParam("KABOUM_OPMODES_LIST", null);
        // Default activated opMode
        initParam("KABOUM_DEFAULT_OPMODE", null);

        ///////////////// initializing GIS model /////////////////////////////

        // initialize applet canvas and internal size
        setLayout(null);
        // Get current graphical context
        g = getGraphics();
        // Applet size initialisation
        changeAppletSize(this.getSize().width, this.getSize().height, true);

        setMapServerTools();
        // Index extent initialisation is done in MapserverTools ctor
        //this.GGDIndex.setExtent(this.mapServerTools.getExtent());

        // now size is set, can handle vector features
        initParam("KABOUM_FEATURESERVER_URL", null);
        // Object classes descriptor: now loaded by KaboumFeatureServer class
        this.loadGeoClassesParameters();

        // First map image is unique to avoid browser caching problems
        swapImage(KaboumUtil.toURL(this.mapServerTools.getMapString()));
        
        // Initialize history
        mapServerTools.historyAddExtent(this.mapServerTools.getExtent().kaboumExternalString());
        
        
        // Envoi des coordonnees au navigateur
        kaboumResult("EXTENT|MAP|"+mapServerTools.getRealExtent().kaboumExternalString());
        kaboumResult("SCALE|" + mapServerTools.getScale());
        
        // nico add-on: in case of applet reference, must init it with current extent
        if (ref_is_applet) {
            kaboumResult("REFERENCE|" + mapServerTools.getRealExtent().kaboumExternalString());
        }
        
        // Default OpMode
        kaboumCommand(this.currentCommand);
        
        // Send the loading message to navigator
        kaboumResult("ALERT|KABOUM_IS_LOADED");
    }

    /** changes the size of the applet according to given dimensions.
     * Also updates the internal canvas, the MapServerTools extent information
     * and the mapserver image size
     * @param w the new applet/ms image width
     * @param h the new applet/ms image height
     */
    private void changeAppletSize(int w, int h, boolean force) {
        if (this.getSize().width == w && this.getSize().height == h && !force) {
            KaboumUtil.debug("New size = old size. Size change ignore...");
            return;
        }
        this.setSize(w, h);
        this.screenSize = this.getSize();
        KaboumUtil.debug("applet size set: " + this.screenSize);

        // Double buffering avoid flickering
        this.offScreenImage = createImage(screenSize.width, screenSize.height);
        this.offScreenGraphics = offScreenImage.getGraphics();

        if (this.mapServerTools != null ) {
            // fixme: check if it propagates the new dimension to everyone
            this.mapServerTools.setScreenSize(screenSize);
            this.mapServerTools.setAdjustedCoordinates();
        } else {
            KaboumUtil.debug("Null mapserverTools: cannot set the new size...");
        }

    }
    
    /**
     *
     * Sets the mapServerTools based on the loaded properties.
     * can be called by initializer or dynamic parameters setter function
     * Caution: must be called after kaboumProperties hashtable is loaded
     * with all required parameters for the mapServerTools ctor.
     */
    private void setMapServerTools() {
        this.mapServerTools = new KaboumMapServerTools(
                (String)kaboumProperties.get("KABOUM_MAPSERVER_CGI_URL"),
                (String)kaboumProperties.get("MAPFILE_PATH"),
                KaboumUtil.stoi((String)kaboumProperties.get("KABOUM_HISTORY_SIZE")),
                this.pm,
                (String)kaboumProperties.get("LAYERS"),
                (String)kaboumProperties.get("QUERY_LAYERS"),
                restrictedExtent,
                KaboumUtil.stoi((String)kaboumProperties.get("KABOUM_MAXIMUM_SCALE"), -1),
                KaboumUtil.stob((String)kaboumProperties.get("KABOUM_USE_IMAGE_CACHING"), true),
                mapExtent,
                this.screenSize,
                this.GGDIndex
                );
    }
    
    /**
     * Sets initial Kaboum Parameters.
     * Allows to overload init parameters programatically, by sending a
     * command to kaboumCommand: INIT_PARAM|<PARAM_NAME>=<PARAM_VALUE>
     * where PARAM_NAME and PARAM_VALUE are the parameters name and value, respectively
     * @param param the name of the parameter to set (see Kaboum Doc)
     * @param value the string representing the value to set for the given parameter, or
     * null to use the kaboum applet tag parameters
     */
    public void initParam(String param, String value) {
        if (param == null) {
            return;
        }
        String inputAppletParameter = null;
        StringTokenizer st = null;
        String trueValue = null;
        if ("KABOUM_SHOW_APPLET_NAME_IN_RESULT".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_SHOW_APPLET_NAME_IN_RESULT") : value;
            this.showAppletName = KaboumUtil.stob(trueValue, false);
        } else if ("KABOUM_APPLET_NAME".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_APPLET_NAME") : value;
            this.appletName = trueValue;
        } else if ("KABOUM_DEBUG_MODE".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_DEBUG_MODE") : value;
            KaboumUtil.setDebugMode(KaboumUtil.stob(trueValue, false));
        } else if ("MAPFILE_UNITS".equals(param)) {
            //TODO: manage units dynamically, not only from applet parameters
            this.pm = new KaboumPrecisionModel(
                    KaboumPrecisionModel.sToUnit(getParameter("")),
                    KaboumPrecisionModel.sToSurface(getParameter("SURFACE_UNITS")),
                    KaboumUtil.stof(getParameter("KABOUM_SURFACE_PRECISION"), 1));
            
            // Set the Precision Model for KaboumExtent class
            KaboumExtent.setPM(this.pm);
        } else if ("KABOUM_REFERENCE_MAP_IS_APPLET".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_REFERENCE_MAP_IS_APPLET") : value;
            this.ref_is_applet = KaboumUtil.stob(trueValue, this.ref_is_applet);
        } else if ("KABOUM_BACKGROUND_COLOR".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_BACKGROUND_COLOR"): value;
            this.bgColor = KaboumUtil.getColorParameter(trueValue, this.bgColor);
            setBackground(bgColor);
        } else if ("KABOUM_USE_LIVECONNECT".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_USE_LIVECONNECT"): value;
            this.isJavascriptEnabled = KaboumUtil.stob(trueValue, this.isJavascriptEnabled);
        } else if ("KABOUM_SEND_POSITION_COORDINATES_TO_JS".equals(param)) {
            trueValue = value == null ?
                getParameter("KABOUM_SEND_POSITION_COORDINATES_TO_JS") :value;
            this.sendPositionCoordinatesToJS = KaboumUtil.stob(trueValue, this.sendPositionCoordinatesToJS);
        } else if ("KABOUM_BUSY_IMAGE_URL".equals(param)) {
            trueValue = (value == null) ? getParameter("KABOUM_BUSY_IMAGE_URL") : value;
            if (trueValue != null) {
                busyImg = readImage(this, KaboumUtil.toURL(trueValue));
            }
        } else if ("KABOUM_LANG".equals(param)) {
            trueValue = (value == null) ? getParameter("KABOUM_LANG") : value;
            this.defaultLang = new KaboumLang(trueValue, this.getCodeBase());
        } else if ("GEOMETRY_DEFAULT_ID".equals(param)) {
            if (value == null) {
                trueValue = getParameter("GEOMETRY_DEFAULT_ID") == null ? K_NEW_GEOMETRY : getParameter("GEOMETRY_DEFAULT_ID");
            } else {
                trueValue = value;
            }
            K_NEW_GEOMETRY = trueValue;
        } else if ("MAPFILE_EXTENT".equals(param)) {
            trueValue = value == null ? getParameter("MAPFILE_EXTENT") : value;
            
            if (trueValue != null) {
                st = new StringTokenizer(trueValue, ",");
                if (st.countTokens() != 4) {
                    KaboumUtil.debug("Wrong Extent!!! Not enough parameter in Extent");
                    System.exit(0);
                }
                KaboumCoordinate coordLL = new KaboumCoordinate(KaboumUtil.stod(st.nextToken()), KaboumUtil.stod(st.nextToken()));
                KaboumCoordinate coordUR = new KaboumCoordinate(KaboumUtil.stod(st.nextToken()), KaboumUtil.stod(st.nextToken()));
                
                mapExtent = new KaboumExtent(this.pm.toInternal(coordLL), this.pm.toInternal(coordUR));
            } else {
                KaboumUtil.debug("ERROR : you must specify parameter MAPFILE_EXTENT");
                System.exit(0);
            }
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("KABOUM_MAXIMUM_EXTENT".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_MAXIMUM_EXTENT"): value;
            
            if (trueValue != null) {
                st = new StringTokenizer(trueValue, ",");
                if (st.countTokens() != 4) {
                    KaboumUtil.debug("Wrong Restricted Extent!!!");
                } else {
                    KaboumCoordinate coordLL = new KaboumCoordinate(KaboumUtil.stod(st.nextToken()), KaboumUtil.stod(st.nextToken()));
                    KaboumCoordinate coordUR = new KaboumCoordinate(KaboumUtil.stod(st.nextToken()), KaboumUtil.stod(st.nextToken()));
                    
                    restrictedExtent = new KaboumExtent(this.pm.toInternal(coordLL), this.pm.toInternal(coordUR));
                }
            }
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("KABOUM_MAPSERVER_CGI_URL".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_MAPSERVER_CGI_URL"): value;
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("MAPFILE_PATH".equals(param)) {
            trueValue = value == null ? getParameter("MAPFILE_PATH"): value;
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("KABOUM_HISTORY_SIZE".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_HISTORY_SIZE"): value;
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("LAYERS".equals(param)) {
            trueValue = value == null ? getParameter("LAYERS"): value;
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("QUERY_LAYERS".equals(param)) {
            trueValue = value == null ? getParameter("QUERY_LAYERS"): value;
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("KABOUM_MAXIMUM_SCALE".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_MAXIMUM_SCALE"): value;
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("KABOUM_USE_IMAGE_CACHING".equals(param)) {
            trueValue = value == null ? getParameter("KABOUM_USE_IMAGE_CACHING"): value;
            if (value != null) {
                //rebuild mapserverTools only if a true parameter value is passed
                setMapServerTools();
            }
        } else if ("KABOUM_IMAGE_TYPE".equals(param)) {
            // Default output image type
            inputAppletParameter = value == null ? getParameter("KABOUM_IMAGE_TYPE") : value;
            if (inputAppletParameter != null) {
                this.mapServerTools.setImageType(inputAppletParameter);
            }
        } else if ("KABOUM_IMAGE_QUALITY".equals(param)) {
            inputAppletParameter = value == null ? getParameter("KABOUM_IMAGE_QUALITY"): value;
            if (inputAppletParameter != null) {
                this.mapServerTools.setImageQuality(KaboumUtil.stoi(inputAppletParameter));
            }
        } else if ("KABOUM_OPMODES_LIST".equals(param)) {
            inputAppletParameter = value == null ? getParameter("KABOUM_OPMODES_LIST"): value;
            if (inputAppletParameter != null) {
                st = new StringTokenizer(inputAppletParameter, ",");
                while(st.hasMoreTokens()) {
                    
                    String tmpStr = st.nextToken().toUpperCase();
                    this.opModeHash.put(tmpStr, tmpStr);
                    
                    String[] tmpList = null;
                    try {
                        tmpList = (String[]) Class.forName(pkName + "Kaboum" + tmpStr + "OpMode")
                        .getMethod("getParametersList", (Class[])null)
                        .invoke(null, (Object[])null);
                    } catch (Exception jse) {
                        KaboumUtil.debug("WARNING! : " + tmpStr + " opMode not present in jar file");
                        continue;
                    }
                    
                    if (tmpList != null) {
                        for (int i = 0; i < tmpList.length; i++) {
                            String tmpStr2 = (String) tmpList[i];
                            if (getParameter(tmpStr2) != null) {
                                this.opModePropertiesHash.put(tmpStr2, getParameter(tmpStr2));
                            }
                        }
                    }
                }
            }
        } else if ("KABOUM_FEATURESERVER_URL".equals(param) || "KABOUM_FEATURESERVER_PROPERTIES".equals(param)) {
            inputAppletParameter = value == null ? getParameter("KABOUM_FEATURESERVER_URL"): value;
            if (inputAppletParameter != null ) {
                // if this parameter is filled, use it instead of default properties file configured
                // in the KaboumFeatureServlet
                String propsFile = getParameter("KABOUM_FEATURESERVER_PROPERTIES");
                featureServerTools = new KaboumFeatureServerTools(
                        this,
                        inputAppletParameter,
                        this.mapServerTools.getExtent());
                featureServerTools.setPropertiesFile(propsFile);
                // geometry visibility reconstruction is done by the featureServerTools when getting new geometries.
                // creates a KaboumOpModeStatus object and reference it to kaboum.
                opModeStatus = new KaboumOpModeStatus();
            }
        } else if ("KABOUM_DEFAULT_OPMODE".equals(param)) {
            this.currentCommand = getParameter("KABOUM_DEFAULT_OPMODE", this.currentCommand);
        } else {
            // opmode params, stores them like this
            if (this.opModePropertiesHash != null) {
                this.opModePropertiesHash.put(param, value);
            }
        }
        // register the parameter and value into properties hashtable
        if (trueValue != null) {
            kaboumProperties.put(param, trueValue);
        }
    }
    
    
    /**
     *
     * Return the opMode property corresponding to the
     * input key
     *
     * @param key String key
     *
     */
    public String getOpModeProperty(String key) {
        return (String) this.opModePropertiesHash.get(key);
    }
    
    
    //******************* JAVA ----> HTML ******************************
    
    /**
     *
     * This method sends result to the HTML page via
     * LiveConnect (cf:javascript).
     * It's called by opMode with an extra-applet
     * effect (like QUERY for example).
     * It assumed that the javascript method "kaboumResult"
     * exist in the parent html page code.
     *
     * @param str Submitted command string
     *
     */
    public boolean kaboumResult(String str) {
        if (isJavascriptEnabled) {
            try {
                if (this.showAppletName) {
                    str = this.appletName + "|" + str;
                }
                KaboumUtil.debug("TO JS : " + str);
                window.eval("kaboumResult('"+str+"')");
            } catch (Exception jse) {
                KaboumUtil.debug(" WARNING ! Error in javascript function KaboumResult()");
                KaboumUtil.debug("kaboumResult parameter was: " + str);
                jse.printStackTrace();
                return false;
            }
        } else {
            return false;
        }
        
        return true;
    }
    
    
    //******************* HTML ----> JAVA ******************************
    
    /**
     *
     * This method is the control center of the applet.
     * It's called by javascript in a form like:
     * document.kaboum.kaboumCommand(str), where
     * str is a string containing either a key
     * and an associated value separated by "|"
     * (command parameters or values), or just a key. In this case
     * the key change the active opMode
     *
     * !!!!! WARNING !!!!!
     *
     * Input coordinates MUST BE in external representation
     *
     * Examples:
     *
     *  - change map view to a new box extent:
     *
     *        str = "EXTENT|x1,y1;x2,y2"
     *
     *  - center map view on a point:
     *
     *        str = "EXTENT|x1,y1,-10,-10"
     *
     *  - center map view on a point and zoom + by a factor of 2:
     *
     *        str = "EXTENT|x1,y1,-1,-1"
     *
     *  - center map view on a point and zoom - by a factor of 2:
     *
     *        str = "EXTENT|x1,y1,-5,-5"
     *
     *  - change layers to draw:
     *
     *        str = "LAYERS|rivers,lakes,country"
     *
     *  - put the applet in zoom + state
     *
     *        str = "ZOOMIN"
     *
     *  - put the applet in query state
     *
     *        str = "QUERY"
     *
     *  - etc...
     *
     * @param str Submited command string
     *
     */
    
    public boolean kaboumCommand(String str) {
        
        if (str == null) {
            return false;
        }
        
        // On ne prends pas de commande tant que l'applet
        // est en standby
        if (systemStandby) {
            return false;
        }
        StringTokenizer st = new StringTokenizer(str, "|");
        int tokenNumber = st.countTokens();
        
        // Message a l'attention des gentils utilisateurs...
        showMessage(this.defaultLang.getString("PROCESSING_MESSAGE"));
        
        // Logs
        KaboumUtil.debug("Command passed to applet : " + str);
        
        if (tokenNumber == 1) {
            return this.processCommand(st.nextToken().toUpperCase());
        } else if (tokenNumber == 2) {
            String key = st.nextToken();
            String value = st.nextToken();
            return this.processCommand(key, value);
        } else if (tokenNumber == 3) {
            String key = st.nextToken();
            String modifier = st.nextToken();
            String value = st.nextToken();
            return this.processCommand(key, modifier, value);
        } else if (tokenNumber == 4) {
            String key = st.nextToken();
            String className = st.nextToken();
            String id = st.nextToken();
            String value = st.nextToken();
            return this.processCommand(key, className, id, value);
        } else if (tokenNumber == 5) {
            String key = st.nextToken();
            String idStr = st.nextToken();
            String ddName = st.nextToken();
            String pdName = st.nextToken();
            String value = st.nextToken();
            return this.processCommand(key, idStr, ddName, pdName, value);
        }
        
        return false;
        
    }
    
    
    /**
     *
     * Process an input command with one parameter
     *
     * @param currentCommand First parameter
     *
     */
    private boolean processCommand(String currentCommand) {
        
        // Save the currentOpMode
        KaboumOpMode tmpOpMode = this.currentOpMode;
        
        if (currentCommand.equals("LAYERS")) {
            mapServerTools.setLayersList(null);
            swapImage(KaboumUtil.toURL(mapServerTools.getMapString()));
        } else if(currentCommand.equals("QUERY_LAYERS")) {
            mapServerTools.setQueryLayersList(null);
        } else if (currentCommand.equals("REFRESH")) {
            swapImage(KaboumUtil.toURL(mapServerTools.getMapString()));
        } else if (currentCommand.equals("CURRENT_OPMODE")) {
            // a new command (2006-03-23) returning  the current opMode name with the following syntax:
            // CURRENT_OPMODE|<opModeName> (or null if there is no current op mode)
            kaboumResult("CURRENT_OPMODE|" + (currentOpMode == null ? "null": currentOpMode.getOpModeName()));
        } else if (currentCommand.equals("EDITION_OPMODE")) {
            // a new command (2006-03-23) Telling if one the edition drawers is in an intermediate state:
            // a operation was done, but not yet validated or cancelled by the user.
            // Kaboum returns to JS the following command:
            // EDITION_OPMODE|<opModeName> where <opModeName> is the name of the opMode in edition mode, or
            // "null" if there is no current edition mode
            String editionModeName = "null";
            if (opModeStatus.isEditionPending) {
                editionModeName = opModeStatus.opModeName;
            }
            kaboumResult("EDITION_OPMODE|" + editionModeName);
        } else {
            Class[] myClass = new Class[1];
            myClass[0] = this.getClass();
            Object[] myParams = new Object[1];
            myParams[0] = this;
            
            this.destroyCurrentOpMode();
            
            try {
                // added here (NRI, may 9 2006) code to check if an edition is currently pending. If so,
                // warn user by JS command.
                // code testing pending status moved from each edition OpMode to here, to avoid ugly code.
                if (opModeStatus != null && opModeStatus.isEditionDrawer(currentCommand) &&
                        opModeStatus.isEditionPending &&
                        ! currentCommand.equals(opModeStatus.opModeName)) {
                    kaboumResult("ALERT|FINISH_TOOL:" + opModeStatus.opModeName);
                    return false;
                }
                this.currentOpMode = (KaboumOpMode) Class.forName(pkName + "Kaboum" + currentCommand + "OpMode").getConstructor(myClass).newInstance(myParams);
                //this.currentOpMode = new KaboumPOLYGONOpMode(this);
                this.currentCommand = currentCommand;
            } catch (Exception jse) {
                KaboumUtil.debug(" WARNING ! : command " + currentCommand + " not found or opMode not present in jar file");
                this.currentOpMode = tmpOpMode;
                jse.printStackTrace();
                return false;
            }
            this.panStatus = currentCommand.equals("PAN");
            
            this.update(g);
        }
        return true;
    }
    
    
    /**
     *
     * Process an input command with 2 parameters
     *
     * @param key       First parameter
     * @param value     Second parameter
     *
     */
    private boolean processCommand(String key, String value) {
        
        // Save the currentOpMode
        KaboumOpMode tmpOpMode = this.currentOpMode;
        
        if (key.equalsIgnoreCase("GEOMETRY_DEFAULT_ID")) {
            K_NEW_GEOMETRY = value;
        } else  if (key.equalsIgnoreCase("GEOMETRY")) {
            // TOGGLE_VISIBILITY
            if ("TOGGLE_VISIBILITY".equalsIgnoreCase(value) && this.GGDIndex != null) {
                this.GGDIndex.hideGeometries = !this.GGDIndex.hideGeometries;
                this.repaint();
                kaboumCommand("GEOMETRY|VISIBLE|"+this.GGDIndex.hideGeometries);
                KaboumUtil.debug("HIDE GEOMETRIES ? : " + this.GGDIndex.hideGeometries);
            }
        } else if (key.equalsIgnoreCase("LAYERS")) {
            mapServerTools.setLayersList(value);
            // NRI test: when refreshing layer list, no need to get vector objects
            if (featureServerTools != null) {
                featureServerTools.standbyOn();
            }
            swapImage(KaboumUtil.toURL(mapServerTools.getMapString()));
            
            if (featureServerTools != null) {
                featureServerTools.standbyOff();
            }
        } else if (key.equalsIgnoreCase("HISTORY")) {
            if (value.equalsIgnoreCase("BACK")) {
                String tmpStrHist = mapServerTools.historyPrevExtent();
                if (tmpStrHist != null) {
                    kaboumCommand("EXTENT|MAP|"+tmpStrHist);
                }
            } else if (value.equalsIgnoreCase("FORWARD")) {
                String tmpStrHist = mapServerTools.historyNextExtent();
                if (tmpStrHist != null) {
                    kaboumCommand("EXTENT|MAP|"+tmpStrHist);
                }
            }
        } else if (key.equalsIgnoreCase("PRINT_URL")) {
            StringTokenizer stCoord;
            stCoord = new StringTokenizer(value, ",");
            int tmpWidth = KaboumUtil.stoi(stCoord.nextToken());
            int tmpHeight = KaboumUtil.stoi(stCoord.nextToken());
            kaboumResult("PRINT_URL|"+mapServerTools.getPrintURL(tmpWidth, tmpHeight));
        } else if (key.equalsIgnoreCase("SCALE")) {
            
            mapServerTools.zoomToMapExtent((double) screenSize.width / 2.0,
                    (double) screenSize.height / 2.0,
                    mapServerTools.setScale(KaboumUtil.stoi(value)));
            
            // Communication java ---> javascript
            if (isJavascriptEnabled) {
                try {
                    window.eval("kaboumResult('EXTENT|MAP|"+mapServerTools.getRealExtent().kaboumExternalString()+"')");
                    if (!ref_is_applet) {
                        window.eval("kaboumResult('REFERENCE|"+mapServerTools.getReferenceString()+"')");
                    } else {
                        window.eval("kaboumResult('REFERENCE|"+mapServerTools.getRealExtent().kaboumExternalString()+"')");
                    }
                    window.eval("kaboumResult('SCALE|"+mapServerTools.getScale()+"')");
                } catch (Exception jse) { jse.printStackTrace(); }
            }
            
            swapImage(KaboumUtil.toURL(mapServerTools.getMapString()));
            mapServerTools.historyAddExtent(mapServerTools.getExtent().kaboumExternalString());
            
            this.update(g);
            
        } else if (key.equalsIgnoreCase("QUERY_LAYERS")) {
            mapServerTools.setQueryLayersList(value);
        } else if (key.equalsIgnoreCase("KABOUM_IMAGE_TYPE")) {
            mapServerTools.setImageType(value);
            swapImage(KaboumUtil.toURL(mapServerTools.getMapString()));
        } else if (key.equalsIgnoreCase("KABOUM_IMAGE_QUALITY")) {
            mapServerTools.setImageQuality(KaboumUtil.stoi(value));
            swapImage(KaboumUtil.toURL(mapServerTools.getMapString()));
        } else if (key.equalsIgnoreCase("GEOMETRY_ACTIVE_DD")) {
            
            KaboumGeometryDisplayDescriptor tmpDD = null;
            tmpDD = (KaboumGeometryDisplayDescriptor) this.geometryDDHash.get(value);
            
            if (tmpDD == null) {
                if (this.currentDD == null) {
                    this.currentDD = defaultDD;
                    return false;
                }
            } else {
                this.currentDD = tmpDD;
            }
            
            return true;
            
        } else if (key.equalsIgnoreCase("GEOMETRY_ACTIVE_PD")) {
            
            KaboumGeometryPropertiesDescriptor tmpPD = (KaboumGeometryPropertiesDescriptor) this.geometryPDHash.get(value);
            
            if (tmpPD == null) {
                if (this.currentPD == null) {
                    this.currentPD = defaultPD;
                    return false;
                }
            } else {
                this.currentPD = tmpPD;
            }
            
            return true;
        }

        
        //
        // KABOUM_ACTION is a special keyword.
        // It send the "value" keyword to the supposed
        // existing actionPerformed(ActionEvent e) of
        // the currentOpMode
        //
        else if (key.equalsIgnoreCase("KABOUM_ACTION")) {
            this.currentOpMode.actionPerformed(new ActionEvent(this.currentOpMode, 0, value));
        }
        
        //
        // Add a new valid Display Descriptor
        //
        else if (key.equalsIgnoreCase("ADD_NEW_DD")) {
            if (this.geometryDDHash.get(key) != null) {
                return false;
            }
            KaboumGeometryDisplayDescriptor tmpDD = new KaboumGeometryDisplayDescriptor(value);
            this.geometryDDHash.put(key, tmpDD);
        }
        
        //
        // Add a new valid Properties Descriptor
        //
        else if (key.equalsIgnoreCase("ADD_NEW_PD")) {
            if (this.geometryPDHash.get(key) != null) {
                return false;
            }
            KaboumGeometryPropertiesDescriptor tmpPD = new KaboumGeometryPropertiesDescriptor(value);
            this.geometryDDHash.put(key, tmpPD);
        } else if (key.equalsIgnoreCase("SET_INLINE")) {
            if (value.equalsIgnoreCase("CLEAR")) {
                this.mapServerTools.displayInline = false;
            }
        }
        // NRI - 21 avril 2005: manage the new QUERY_ITEM or QUERY_NITEM mode
        // THe 2-parameters command allow to clear the QUERY_ITEM mode and to return
        // to the normal applet behaviour, in term of mapserver URL generation
        else if ( (key.equalsIgnoreCase("ITEM_QUERYMAP") || key.equalsIgnoreCase("ITEM_NQUERYMAP")) &&
                "CLEAR".equalsIgnoreCase(value))  {
            this.mapServerTools.displayItemQueryMap = false;
        }
        
        //NRI 14 aout 2005: added a new Command to toggle features retrieval
        else if ("OBJECT".equalsIgnoreCase(key)) {
            if (featureServerTools != null) {
                if ("ON".equalsIgnoreCase(value)) {
                    featureServerTools.standbyOff();
                } else if ("OFF".equalsIgnoreCase(value)) {
                    featureServerTools.standbyOn();
                }
            }
        }
        
        //NRI 23 juin 2008: added a new Command to set the userMetadata string.
        else if ("USER_METADATA".equalsIgnoreCase(key)) {
            this.userMetadata = value;
        }
        // NRI 10 juin 2009
        // new mode to pass applet canvas size to kaboum, allowing it to ask mapserver for
        // the right image size, to compute extents correctly and to resize the internal applet component
        else if (key.equalsIgnoreCase("CANVAS_SIZE")) {
            KaboumUtil.debug("setting new size for canvas: " + value);
            String[] coords = value.split(" ");
            if (coords.length == 2) {
                int w = Integer.parseInt(coords[0]);
                int h = Integer.parseInt(coords[1]);
                changeAppletSize(w, h, true);
            }
        }

        //
        // Overload Display Descriptors parameters
        //
        else if (key.indexOf("_DD_") != -1) {
            return this.overloadDescriptorParameter("_DD_", key, value);
        }
        
        else if (key.indexOf("_PD_") != -1) {
            KaboumUtil.debug("setting key: " + key + " value:" + value);
            return this.overloadDescriptorParameter("_PD_", key, value);
            
        } else if (key.equalsIgnoreCase("INIT_PARAM")) {
            // a new command allowing to overload Kaboum init parameters.
            // the value must be an initialisation parameters, in the form NAME=VALUE
            StringTokenizer st = new StringTokenizer(value, "=");
            if (st.countTokens() != 2) {
                // not a valid parameter string
                KaboumUtil.debug("Invalid INIT_PARAM command: cannot recognize parameter: " + value);
                return false;
            }
            String pName = st.nextToken().trim();
            String pValue = st.nextToken().trim();
            
            initParam(pName, pValue);
            return true;
            
        }
        
        //
        // In other cases the command could be:
        //    1. a opMode with parameters
        //    2. a key for the opModePropertiesHash
        //
        else {
            
            // Case 1.
            Class[] myClass = new Class[2];
            myClass[0] = this.getClass();
            myClass[1] = (new String()).getClass();
            Object[] myParams = new Object[2];
            myParams[0] = this;
            myParams[1] = value;
            boolean test = false;
            
            this.currentCommand = key.toUpperCase();
            
            this.destroyCurrentOpMode();
            
            try {
                currentOpMode = (KaboumOpMode) Class.forName(pkName + "Kaboum" + currentCommand + "OpMode").getConstructor(myClass).newInstance(myParams);
                this.panStatus = key.equals("PAN");
                test = true;
            } catch (Exception jse) {
                KaboumUtil.debug(" WARNING ! : command " + currentCommand + " not found or opMode not present in jar file");
                jse.printStackTrace();
                test = false;
            }
            
            if (test == false) {
                this.currentOpMode = tmpOpMode;
                this.opModePropertiesHash.put(key.toUpperCase(), value);
                this.update(g);
            }
            
            return true;
        }
        return true;
    }
    
    
    /**
     *
     * Process an input command with 3 parameters
     *
     * @param key       First parameter
     * @param modifier  Second parameter
     * @param value     Third parameter
     *
     */
    private boolean processCommand(String key, String modifier, String value) {
        
        StringTokenizer stCouple = new StringTokenizer(value, ";");
        
        if (key.equalsIgnoreCase("EXTENT")) {
            
            StringTokenizer stCoord;
            double x1 = Double.MIN_VALUE;
            double y1 = Double.MIN_VALUE;
            double x2 = Double.MAX_VALUE;
            double y2 = Double.MAX_VALUE;
            
            if (stCouple.countTokens() == 1) {
                stCoord = new StringTokenizer(stCouple.nextToken(), ",");
                x1 = KaboumUtil.stod(stCoord.nextToken());
                y1 = KaboumUtil.stod(stCoord.nextToken());
            } else if (stCouple.countTokens() == 2) {
                stCoord = new StringTokenizer(stCouple.nextToken(), ",");
                
                x1 = KaboumUtil.stod(stCoord.nextToken());
                y1 = KaboumUtil.stod(stCoord.nextToken());
                stCoord = new StringTokenizer(stCouple.nextToken(), ",");
                x2 = KaboumUtil.stod(stCoord.nextToken());
                y2 = KaboumUtil.stod(stCoord.nextToken());
            } else {
                return false;
            }
            if (modifier.toUpperCase().equals("IMAGE")) {
                // Initialise the new spatial extension
                
                if (x2 > -1 && y2 > -1) {
                    // BOX SELECTION
                    mapServerTools.boxToMapExtent(x1, y1, x2, y2);
                } else if (x2 == -1 && y2 == -1) {
                    // ZOOM +
                    mapServerTools.zoomToMapExtent(x1, y1, 2);
                } else if (x2 == -5 && y2 == -5) {
                    // ZOOM -
                    mapServerTools.zoomToMapExtent(x1, y1, 0.5);
                } else if (x2 == -10 && y2 == -10) {
                    // CENTER / PAN
                    mapServerTools.zoomToMapExtent(x1, y1, 1);
                }
                
                else {
                    return false;
                }
                
                // Communication java ---> javascript
                if (isJavascriptEnabled) {
                    try {
                        window.eval("kaboumResult('EXTENT|MAP|"+mapServerTools.getRealExtent().kaboumExternalString()+"')");
                        if (!ref_is_applet) {
                            window.eval("kaboumResult('REFERENCE|"+mapServerTools.getReferenceString()+"')");
                        } else {
                            window.eval("kaboumResult('REFERENCE|"+mapServerTools.getRealExtent().kaboumExternalString()+"')");
                        }
                        window.eval("kaboumResult('SCALE|"+mapServerTools.getScale()+"')");
                    } catch (Exception jse) {
                        jse.printStackTrace();
                    }
                }
            } else if (modifier.toUpperCase().equals("MAP")) {
                
                if (x2 == Double.MAX_VALUE && y2 == Double.MAX_VALUE) {
                    mapServerTools.centerMapExtent(this.pm.toInternal(x1, y1));
                } else {
                    mapServerTools.setExtent(new KaboumExtent(this.pm.toInternal(x1, y1), this.pm.toInternal(x2, y2)));
                }
                
                // Communication java ---> javascript
                if (isJavascriptEnabled) {
                    try {
                        window.eval("kaboumResult('EXTENT|MAP|"+mapServerTools.getRealExtent().kaboumExternalString()+"')");
                        if (!ref_is_applet) {
                            window.eval("kaboumResult('REFERENCE|"+mapServerTools.getReferenceString()+"')");
                        } else {
                            window.eval("kaboumResult('REFERENCE|"+mapServerTools.getRealExtent().kaboumExternalString()+"')");
                        }
                        window.eval("kaboumResult('SCALE|"+mapServerTools.getScale()+"')");
                    } catch (Exception jse) {
                        jse.printStackTrace();
                    }
                }
            } else {
                return false;
            }
            
            swapImage(KaboumUtil.toURL(mapServerTools.getMapString()));
            mapServerTools.historyAddExtent(mapServerTools.getExtent().kaboumExternalString());
            
        } else if(key.equalsIgnoreCase("LANG")) {
            this.defaultLang.set(modifier, value);
            return true;
        } else if (key.equalsIgnoreCase("MENU")) {
            
            KaboumGeometryPropertiesDescriptor tmpPD = (KaboumGeometryPropertiesDescriptor) this.geometryPDHash.get(modifier);
            
            //
            // Check if tmpPD existS
            //
            if (tmpPD == null) {
                
                // Logs
                KaboumUtil.debug("Warning! Properties Descriptor "+modifier+" doesn't exist"+ ". Action "+key+" aborted");
                return false;
            }
            
            if (value.equalsIgnoreCase("CLEAR")) {
                tmpPD.clearMenu();
                return true;
            }
            
        }
        
        // CHANGE COLOR
        else if (key.equalsIgnoreCase("GEOMETRY_COLOR")) {
            
            KaboumGeometryGlobalDescriptor tmpGGD = this.GGDIndex.getGGD(modifier);
            
            // Check if unique id of object exists
            if (tmpGGD == null) {
                // Logs
                KaboumUtil.debug("Cannot change color: GEOMETRY " + modifier + " doesn't exist");
                return false;
            }
            
            tmpGGD.color = KaboumUtil.getColorParameter(value, Color.black);
            
            //
            // If the ownColor is null then
            // TRANSPARENT must have been called
            //
            
            if (tmpGGD.color == null) {
                if (tmpGGD.geometry.isClosed()) {
                    tmpGGD.isTranslucent = true;
                } else {
                    tmpGGD.color = Color.black;
                    tmpGGD.isTranslucent = false;
                }
            }
            
            // Repaint the opMode
            this.repaint();
            
        }
        
        // Add a dynamical menu title to the geometry id
        else if (key.equalsIgnoreCase("MENU_TITLE")) {
            
            KaboumGeometryGlobalDescriptor tmpGGD = this.GGDIndex.getGGD(modifier);
            
            // Check if unique id of object exists
            if (tmpGGD == null) {
                
                // Logs
                KaboumUtil.debug("Cannot add menu title : GEOMETRY " + modifier + " doesn't exist");
                
                return false;
                
            }
            
            tmpGGD.setTitleMenu(value);
            
        }
        
        // Add a dynamical tooltip to the geometry id
        else if (key.equalsIgnoreCase("TOOLTIP")) {
            
            KaboumGeometryGlobalDescriptor tmpGGD = this.GGDIndex.getGGD(modifier);
            
            // Check if unique id of object exists
            if (tmpGGD == null) {
                
                // Logs
                KaboumUtil.debug("Cannot add tooltip : GEOMETRY " + modifier + " doesn't exist");
                
                return false;
                
            }
            
            tmpGGD.setTooltip(value);
            
        }
        
        // Geometry command (insert, hilite, info, remove, getUserData, etc...)
        
        else if (key.equalsIgnoreCase("GEOMETRY")) {
            if (value.equalsIgnoreCase("HILITE")) {
                // HILITE case
                KaboumGeometryGlobalDescriptor tmpGGD = this.GGDIndex.getGGD(modifier);
                // Check if unique id of object exists
                if (tmpGGD == null) {
                    KaboumUtil.debug("Cannot hilite GEOMETRY " + modifier + " : it doesn't exist");
                    return false;
                }
                tmpGGD.setSelected(true);
                this.repaint();
                return true;
            } else if (value.equalsIgnoreCase("REMOVE")) {
                if (featureServerTools != null) {
                    // removal operation is done by the server
                    featureServerTools.removeGeometry(modifier, this.currentDD.name, this.currentOpMode.getName());
                } else {
                    int position = this.GGDIndex.getGGDIndex(modifier);
                    // Check if unique id of object exists
                    if (position == -1) {
                        KaboumUtil.debug("Cannot remove GEOMETRY "+modifier+" : it doesn't exist");
                        return false;
                    }
                    // Remove the given element
                    this.GGDIndex.removeGeometry(modifier);
                    this.repaint();
                    return true;
                }
            } else if (value.equalsIgnoreCase("REMOVE_ALL")) {
                KaboumGeometryPropertiesDescriptor tmpPD = (KaboumGeometryPropertiesDescriptor) this.geometryPDHash.get(modifier);
                if (tmpPD == null) {
                    // Logs
                    KaboumUtil.debug("Cannot remove all GEOMETRIES with Properties Descriptor " + modifier + " : it doesn't exist");
                    return false;
                }
                if (featureServerTools != null) {
                    // removal operation is done by the server
                    Vector geoms = this.GGDIndex.getGeometries(modifier);
                    featureServerTools.removeGeometries(geoms, this.currentDD.name, this.currentOpMode.getName());
                } else {
                    // Remove all GEOMETRIES with the given Properties Descriptor
                    this.GGDIndex.removeAllGeometries(tmpPD);
                    this.repaint();
                    return true;
                }
            } else if (value.equalsIgnoreCase("INFO")) {
                KaboumGeometryGlobalDescriptor tmpGGD = (KaboumGeometryGlobalDescriptor) this.GGDIndex.getGGD(modifier);
                if (tmpGGD == null) {
                    // Logs
                    KaboumUtil.debug("Cannot get geometry info for id: " + modifier);
                    return false;
                }
                // Generates an info string for this object: GEOMETRY|ID|PERIMETER|AREA|TOOLTIP
                String info = "GEOMETRY|" + modifier + "|" + tmpGGD.geometry.getPerimeter() + "|" +
                        tmpGGD.geometry.getArea() + "|" + tmpGGD.geometry.getToolTip();
                this.kaboumResult(info);
                return true;
            } else  if (value.equalsIgnoreCase("INFO_ALL")) {
                KaboumGeometryGlobalDescriptor tmpGGD = (KaboumGeometryGlobalDescriptor) this.GGDIndex.getGGD(modifier);
                if (tmpGGD == null) {
                    // Logs
                    KaboumUtil.debug("Cannot get geometry info for id: " + modifier);
                    return false;
                }
                // Generates an info string for this object: GEOMETRY|ID|PERIMETER|AREA|TOOLTIP
                String info = "GEOMETRY|" + modifier + "|" + tmpGGD.geometry.getPerimeter() + "|" +
                        tmpGGD.geometry.getArea() + "|" + tmpGGD.geometry.getToolTip();
                KaboumWKTWriter writer = new KaboumWKTWriter(this.mapServerTools.pm);
                try {
                    info += "|" + writer.write(tmpGGD.geometry);
                } catch (Exception e) {
                    KaboumUtil.debug("cannot get WKT from geom: " + modifier + " message: " + e.getMessage());
                }
                this.kaboumResult(info);
                return true;
            } else  {
                // Other cases are insert cases, either now or existing object, either directly or by 
                // KaboumServer mean
                
                int position = this.GGDIndex.getGGDIndex(modifier);
                // build a dummy object to store identifier
                KaboumGeometry tmpGeo = null;
                try {
                    KaboumWKTReader wktReader = new KaboumWKTReader(this.pm);
                    tmpGeo = wktReader.read(value);
                    tmpGeo.id = modifier;
                    KaboumUtil.debug("Reading WKT geometry " + modifier + ". Get " + tmpGeo.getCoordinates().length + " coordinates");
                } catch (Exception jse) {
                    KaboumUtil.debug(" WARNING ! :  error while reading geometry " + modifier + " exception msg: " + jse.getMessage());
                     return false;
                }
                if (featureServerTools != null) {
                    if (!featureServerTools.validateGeometry(tmpGeo, this.currentDD.name)) {
                        KaboumUtil.debug("Cannot validate given geometry to the server: " + tmpGeo.id);
                    }
                } else {
                    // normal JS validation, without serveur
                    if (tmpGeo != null) {

                        // Add a new object
                        if (position == -1) {
                            KaboumUtil.debug("Insert new geometry " + modifier);
                            this.GGDIndex.addGeometry(tmpGeo, this.currentDD, this.currentPD, null, true);
                        } else {
                            KaboumGeometryGlobalDescriptor tmpGGD = (KaboumGeometryGlobalDescriptor) this.GGDIndex.elementAt(position);
                            if (tmpGGD != null) {
                                KaboumUtil.debug("Overwrite existing geometry " + modifier);
                                tmpGGD.geometry = tmpGeo;
                                tmpGGD.dd = this.currentDD;
                                tmpGGD.pd = this.currentPD;
                            }
                        }
                        // now that server can disable the reconstruction, forces it
                        // in case of manual insert
                        GGDIndex.reconstructVisibleGeometries();
                        if (tmpGeo.isClosed()) {
                            this.currentSurface = tmpGeo.getArea();
                        }
                        this.currentPerimeter = tmpGeo.getPerimeter();
                        KaboumUtil.debug("Insert GEOMETRY " + modifier);
                        this.repaint();
                        return true;
                    }
                }
            }
        }
        // new mode to pass parameters to Mapserver URL (custom parameters for instance
        else if (key.equalsIgnoreCase("MAPSERVER")) {
            if (modifier.equalsIgnoreCase("PARAMETERS")) {
                this.mapServerTools.setCustomMsParams(value);
            }
        }
        //
        // In other cases the command could be:
        //    1. a opMode with parameters
        //
        else {
            
            // Case 1.
            Class[] myClass = new Class[3];
            myClass[0] = this.getClass();
            myClass[1] = (new String()).getClass();
            myClass[2] = (new String()).getClass();
            Object[] myParams = new Object[3];
            myParams[0] = this;
            myParams[1] = modifier;
            myParams[2] = value;
            
            try {
                currentOpMode = (KaboumOpMode) Class.forName(pkName + "Kaboum" + key + "OpMode").getConstructor(myClass).newInstance(myParams);
                if (key.equals("PAN")) {
                    this.panStatus = true;
                } else {
                    this.panStatus = false;
                }
            } catch (Exception jse) {
                KaboumUtil.debug(" WARNING ! : command " + key + " not found or not opMode not present in jar file");
                jse.printStackTrace();
                return false;
            }
            
            return true;
        }
        
        return false;
    }
    
    
    /**
     *
     * Process an input command with 4 parameters
     *
     * @param key         First parameter
     * @param pdName      Second parameter
     * @param id          Third parameter
     * @param value       Fourth parameter
     *
     */
    private boolean processCommand(String key, String pdName, String id, String value) {
        
        if (key.equalsIgnoreCase("SET_INLINE")) {
            
            this.mapServerTools.displayInline = true;
            this.mapServerTools.setInlineFeatureString(pdName, id, value);
            
            return true;
            
        } else {
            KaboumGeometryPropertiesDescriptor tmpPD = (KaboumGeometryPropertiesDescriptor) this.geometryPDHash.get(pdName);

            //
            // Check if className is an existing class
            //
            if (tmpPD == null) {

                // Logs
                KaboumUtil.debug("WARNING ! : Properties Descriptor " + pdName + " doesn't exist ");

                return false;
            }

            // Add a dynamical menu item to the classObject class
            if (key.equalsIgnoreCase("MENU")) {
                tmpPD.addItemToMenu(id, value);
            }
        }
        
        return true;
        
    }
    
    
    /**
     *
     *
     * Process an input command with 5 parameters
     *
     * @param key         First parameter
     * @param idStr       Second parameter
     * @param ddName      Third parameter
     * @param pdName      Fourth parameter
     * @param value       Fifth parameter
     *
     */
    private boolean processCommand(String key, String idStr, String ddName, String pdName, String value) {
        
        if (key.equalsIgnoreCase("ITEM_QUERYMAP") || key.equalsIgnoreCase("ITEM_NQUERYMAP")) {
            // for this command input parameters are these one:
            //key: ITEM_QUERYMAP or ITEM_NQUERYMAP
            //pdName: the name of the layer on which the item query is performed
            // id: the comma-separated list of layer's attribute to search upon (qitems)
            // value: the query string to search for
            
            this.mapServerTools.displayItemQueryMap = true;
            
            // parses ddName parameter, corresponding to the qitem list, to build a string array
            StringTokenizer tok = new StringTokenizer(ddName, ",");
            String[] qitem = new String[tok.countTokens()];
            int i = 0;
            
            while (tok.hasMoreTokens()) {
                qitem[i++] = tok.nextToken();
            }
            
            //forces extent to zoom on selected shapes the first time
            this.mapServerTools.extent.zoomOnShapes = true;
            this.mapServerTools.setItemQueryMapString(key, idStr, qitem, pdName, value);
            
            // then refreshes the mapserver image
            swapImage(KaboumUtil.toURL(mapServerTools.getMapString()));
            
            // then try to find the extent returned by the query to set it to kaboum, thus
            // enabling zoom, pan in the query map
            this.setExtentFromItemQueryMap();
            
            //then restore normal extent behaviour
            this.mapServerTools.extent.zoomOnShapes = false;
            return true;
        } else if (key.equalsIgnoreCase("GEOMETRY")) {
            int position = this.GGDIndex.getGGDIndex(idStr);
            KaboumGeometry tmpGeo = null;
            try {
                KaboumWKTReader wktReader = new KaboumWKTReader(this.pm);
                tmpGeo = wktReader.read(value);
                tmpGeo.id = idStr;
                KaboumUtil.debug("Reading WKT geometry " + idStr + ". Get " + tmpGeo.getCoordinates().length + " coordinates");
            } catch (Exception jse) {
                KaboumUtil.debug(" WARNING ! :  error while reading WKT string " + value);
                return false;
            }
            if (featureServerTools != null) {
                if (!featureServerTools.validateGeometry(tmpGeo, pdName)) {
                    KaboumUtil.debug("Cannot validate given geometry to the server: " + tmpGeo.id);
                }
            } else {
                if (tmpGeo != null && !Kaboum.K_NEW_GEOMETRY.equals(idStr)) {
                    KaboumGeometryPropertiesDescriptor tmpPD = null;
                    tmpPD = (KaboumGeometryPropertiesDescriptor) this.geometryPDHash.get(pdName);

                    if (tmpPD == null) {
                        KaboumUtil.debug("WARNING ! : Properties Descriptor " + pdName + " doesn't exist. Using DEFAULT instead ");
                        tmpPD = this.defaultPD;
                    }
                    KaboumGeometryDisplayDescriptor tmpDD = null;
                    tmpDD = (KaboumGeometryDisplayDescriptor) this.geometryDDHash.get(ddName);

                    if (tmpDD == null) {
                        KaboumUtil.debug("WARNING ! : Display Descriptor " + ddName + " doesn't exist. Using DEFAULT instead ");
                        tmpDD = this.defaultDD;
                    }
                    // Add a new object
                    if (position == -1) {
                        KaboumUtil.debug("Insert new geometry " + idStr);
                        this.GGDIndex.addGeometry(tmpGeo, tmpDD, tmpPD, null, true);
                    } else {
                        KaboumGeometryGlobalDescriptor tmpGGD = (KaboumGeometryGlobalDescriptor) this.GGDIndex.elementAt(position);
                        if (tmpGGD != null) {
                            KaboumUtil.debug("Overwrite existing geometry " + idStr);
                            tmpGGD.geometry = tmpGeo;
                            tmpGGD.dd = tmpDD;
                            tmpGGD.pd = tmpPD;
                        }
                    }
                    if (tmpGeo.isClosed()) {
                        this.currentSurface = tmpGeo.getArea();
                    }
                    this.currentPerimeter = tmpGeo.getPerimeter();
                    this.repaint();
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * sets kaboum extent corresponding to the itemquerymap mode after getting it from mapserver, by parsing the map template.
     * Works only if itemquerymap mode is setup.<br>
     * opens the itemquerymap URL after having removed the "map" part of the mode,
     * to force MS to return a template file in which the current extent is written.<br>
     * If no template file is found, or no extent information is found into the template file,
     * extent is not changed.
     *
     */
    private void setExtentFromItemQueryMap() {
        // gets the itemQueryMapString URL and modifies it to remove the "map" keyword into the itemquerymap or
        // itemnquerymap mode
        int idx = -2;
        int strLen = 0;
        String query = null;
        String newMode = "";
        
        if (mapServerTools.getItemQueryMapString() != null) {
            if ( (idx = mapServerTools.getMapString().indexOf("itemnquerymap")) != -1) {
                newMode = "itemnquery";
                strLen = "itemnquerymap".length();
            } else if ( (idx = mapServerTools.getMapString().indexOf("itemnquerymap")) != -1) {
                newMode = "itemquery";
                strLen = "itemquerymap".length();
            } else {
                return;
            }
        } else {
            return;
        }
        query = mapServerTools.getMapString().substring(0, idx) +
                newMode +
                mapServerTools.getMapString().substring(idx + strLen);
        
        // now opens a connection to this URL to get the template file, and parses it to retrieve the mapserver-generated
        // extent. This extent is located in the first line of the file, after the "mapext=" keyword.
        // the given extent is the extent of the current map
        URL queryURL = null;
        BufferedReader in = null;
        String line = null;
        
        try {
            queryURL = new URL(query);
            
            KaboumUtil.debug("Opening URL connection for query: " + query);
            
            in = new BufferedReader(new InputStreamReader(queryURL.openStream()));
            
            // extent is on the first line of the mapserver header file.
            line = in.readLine();
            
            if ((idx = line.indexOf("mapext=")) != -1) {
                String ext = line.substring(idx + "mapext=".length(), line.lastIndexOf('>'));
                StringTokenizer tok = new StringTokenizer(ext, " ");
                
                double llx = new Double(tok.nextToken()).doubleValue();
                double lly = new Double(tok.nextToken()).doubleValue();
                double urx = new Double(tok.nextToken()).doubleValue();
                double ury = new Double(tok.nextToken()).doubleValue();
                
                this.mapServerTools.setExtent(new KaboumExtent(llx, lly, urx, ury));
                // checks if extent is reduced to a single point. If so, expand it to form a valid extent.
                // do so by adding a 10% buffer around central coordinate
                if (this.mapServerTools.extent.xMin == this.mapServerTools.extent.xMax ||
                        this.mapServerTools.extent.yMin == this.mapServerTools.extent.yMax) {
                    this.mapServerTools.extent.xMin -= (this.mapServerTools.extent.xMin / 20);
                    this.mapServerTools.extent.xMax += (this.mapServerTools.extent.xMin / 20);
                    this.mapServerTools.extent.yMin -= (this.mapServerTools.extent.yMin / 20);
                    this.mapServerTools.extent.yMax += (this.mapServerTools.extent.yMin / 20);
                }
            } else {
                KaboumUtil.debug("No mapext information found in URL stream");
            }
            in.close();
            
        } catch (Exception e) {
            KaboumUtil.debug("an exception occured while retrieving itemquery extent: " + e.toString());
            e.printStackTrace();
        }
    }
    
    /**
     *
     * Overload the Display or Properties Descriptors parameters
     *
     * @param type    DD or PD for a Display or Properties Descriptor respectively
     * @param key     Parameter key
     * @param value   New value affected to the given key
     *
     */
    private boolean overloadDescriptorParameter(String type, String key, String value) {
        
        if (type.equals("_DD_")) {
            
            String[] params = key.split(type);
            String descriptorName = params[0];
            String propertyName = params[1];
            KaboumGeometryDisplayDescriptor tmpDD =  (KaboumGeometryDisplayDescriptor) this.geometryDDHash.get(descriptorName);
            
            if (tmpDD == null) {
                return false;
            }
            
            if (propertyName.equals("COLOR")) {
                tmpDD.setColor(KaboumUtil.getColorParameter(value, this.defaultDD.getColor()));
            } else if (propertyName.equals("HILITE_COLOR")) {
                tmpDD.setHiliteColor(KaboumUtil.getColorParameter(value, this.defaultDD.getHiliteColor()));
            } else if (propertyName.equals("SUPER_HILITE_COLOR")) {
                tmpDD.setSuperHiliteColor(KaboumUtil.getColorParameter(value, this.defaultDD.getSuperHiliteColor()));
            } else if (propertyName.equals("MODIFIED_COLOR")) {
                tmpDD.setModifiedColor(KaboumUtil.getColorParameter(value, this.defaultDD.getModifiedColor()));
            } else if (propertyName.equals("POINT_TYPE")) {
                KaboumCoordinate.stoi(value);
            } else if (propertyName.equals("POINT_HEIGHT")) {
                KaboumUtil.stoi(value);
            } else if (propertyName.equals("POINT_WIDTH")) {
                KaboumUtil.stoi(value);
            } else if (propertyName.equals("POINT_COLOR")) {
                tmpDD.setPointColor(KaboumUtil.getColorParameter(value, this.defaultDD.getPointColor()));
            } else if (propertyName.equals("POINT_HILITE_COLOR")) {
                tmpDD.setPointHiliteColor(KaboumUtil.getColorParameter(value, this.defaultDD.getPointHiliteColor()));
            } else if (propertyName.equals("POINT_IMAGE")) {
                tmpDD.setPointImage(readImage(this, KaboumUtil.toURL(value)));
            } else if (propertyName.equals("IS_FILLED")) {
                tmpDD.setFilling(KaboumUtil.stob(value, false));
            } else {
                return false;
            }
        }
        
        else if (type.equals("_PD_")) {
            String[] params = key.split(type);
            String descriptorName = params[0];
            String propertyName = params[1];
            KaboumGeometryPropertiesDescriptor tmpPD =  (KaboumGeometryPropertiesDescriptor) this.geometryPDHash.get(descriptorName);
            
            if (tmpPD == null) {
                return false;
            }
            
            if (propertyName.equals("IS_VISIBLE")) {
                tmpPD.setVisibility(KaboumUtil.stob(value, true));
            } else if (propertyName.equals("IS_COMPUTED")) {
                tmpPD.setComputation(KaboumUtil.stob(value, false));
            } else if (propertyName.equals("IS_SURROUNDING")) {
                tmpPD.setSurrounding(KaboumUtil.stob(value, false));
            } else if (propertyName.equals("IS_LOCKED")) {
                tmpPD.setLocking(KaboumUtil.stob(value, false));
            } else {
                return false;
            }
        }
        
        this.repaint();
        return true;
    }
    
    /**
     *
     * Set system standby on
     *
     */
    public void standbyOn() {
        this.systemStandby = true;
        destroyCurrentOpMode();
        setCursor("WAIT");
        
        // LOGS
        KaboumUtil.debug(" Mode standby ===> ON");
        
    }
    
    
    /**
     *
     * Set system standby off
     *
     */
    public void standbyOff() {
        this.systemStandby = false;
        setCursor("DEFAULT");
        
        // LOGS
        KaboumUtil.debug(" Mode standby ===> OFF");
        
    }
    
    
    /**
     *
     * Return the active opMode name
     *
     */
    public String getCurrentCommand() {
        return this.currentCommand;
    }
    
    
    
    /**
     *
     * Set pan coordinates
     *
     * @param x X coordinate
     * @param y Y coordinate
     *
     */
    public void setPanCoordinates(int x, int y) {
        this.panCenterX = x;
        this.panCenterY = y;
    }
    
    
    /**
     *
     * Respawn a opMode after its death ;)
     *
     */
    public void respawnOpMode() {
        kaboumCommand(this.currentCommand);
    }
    
    
    /**
     *
     * Destroy target opMode
     *
     * @param opMode OpMode
     *
     */
    public void destroyCurrentOpMode() {
        
        if (this.currentOpMode != null) {
            this.currentOpMode.destroyEvent();
        }
        
        setCursor("DEFAULT");
        this.currentOpMode = null;
        
        // Force the garbage collector
        System.gc();
        
        return;
    }
    
    
    /**
     *
     * Load and return an image.
     *
     * @param imgURL Image URL
     *
     */
    public static Image readImage(Kaboum kaboum, URL imgURL) {
        
        if (imgURL == null) { return null; }
        
        MediaTracker tracker = new MediaTracker(kaboum);
        Image image = Toolkit.getDefaultToolkit().getImage(imgURL);
        
        tracker.addImage(image, 0);
        
        try {
            tracker.waitForID(0);
        } catch (Exception e) {
            
            System.err.println("Exception: " + e.getMessage());
            return null;
        }
        if (image == null)
            System.err.println("Error in reading "+imgURL);
        
        // Logs
        KaboumUtil.debug("image read : "+imgURL);
        
        return image;
    }
    
    
    /**
     *
     * Change the map image.
     *
     * @param imageURL Image URL
     *
     */
    public void swapImage(URL imgURL) {
        
        double startTime = 0;
        double stopTime = 0;
        
        // LOGS
        KaboumUtil.debug(" Mapserver call: " + imgURL.toString());
        
        // Get the current pointer shape
        String tmpCursor = cursorValue;
        
        // Set the wait shape for the mouse pointer
        setCursor("WAIT");
        
        showMessage(this.defaultLang.getString("LOADING_MAP_MESSAGE"));
        
        // Loading the busy Image
        this.busy = true;
        
        // REPAINT
        this.update(g);
        
        // StartTime
        startTime = System.currentTimeMillis();
        
        MediaTracker tracker = new MediaTracker(this);
        
        // Avoid huge memory leak
        if (this.map != null) {
            this.map.flush();
        }
        this.map = null;
        System.gc();
        
        this.map = Toolkit.getDefaultToolkit().getImage(imgURL);
        tracker.addImage(map, 0);
        
        try {
            tracker.waitForID(0);
        } catch (Exception e) {
            System.err.println("Exception: " + e.getMessage());
            return;
        }
        
        // nri 21 avril 2004: added a way to guess if image URL will trully give an image
        // or instead a text.
        // if mode is itemnquerymap and url is not an image,
        // send a new command to the client telling
        // that the query did not find any result
        if (this.mapServerTools.displayItemQueryMap &&
                (tracker.isErrorAny() || tracker.isErrorID(0))) {
            this.kaboumResult("ITEM_NQUERYMAP|NO_RESULT");
            KaboumUtil.debug("Error loading image: errorAny ? " + tracker.isErrorAny() + " errorID(0) ? " + tracker.isErrorID(0));
        }
        // endTime
        stopTime = System.currentTimeMillis();
        
        // Map generation Time
        this.kaboumResult("MAP_TIME_GENERATION|" + ((stopTime - startTime) / 1000));
        
        // NRI: 14 aout 2005
        // refreshes the geometric objects, if any.
        // extent management is supported by mapserverTools.
        if (featureServerTools != null) {
            featureServerTools.getFeatures();
        }
        // Clean the memory
        tracker.removeImage(map);
        tracker = null;
        System.gc();
        
        
        if (map == null) {
            System.err.println("Error in reading "+imgURL);
        }
        
        
        busy = false;
        
        // ...and set the old mouse pointer back
        setCursor(tmpCursor);
        
        showMessage("");
        
        repaint();
        
    }
    
    
    /*
     *
     * Update graphics
     *
     */
    public void update(Graphics g) {
        paint(g);
    }
    
    
    /*
     *
     * Get Font
     *
     */
    public Font getFont() {
        
        // Set the Font parameters
        String fontName = (String) this.opModePropertiesHash.get("KABOUM_FONT_NAME");
        if (fontName == null) {
            fontName = "Courier";
        }
        int fontStyle = KaboumUtil.stoi((String) this.opModePropertiesHash.get("KABOUM_FONT_STYLE"), Font.PLAIN);
        int fontSize = KaboumUtil.stoi((String) this.opModePropertiesHash.get("KABOUM_FONT_SIZE"), 12);
        
        return new Font(fontName, fontStyle, fontSize);
        
    }
    
    
    /*
     *
     * paint
     *
     */
    public void paint(Graphics g) {
        
        int tmpX = 0;
        int tmpY = 0;
        
        Font font = this.getFont();
        offScreenGraphics.setFont(font);
        g.setFont(font);
        
        if (this.panStatus) {
            tmpX = this.panCenterX;
            tmpY = this.panCenterY;
        } else if (this.zoomStatus) {
            tmpX = (int) ((this.screenSize.width / 2) - (2 * this.panCenterX));
            tmpX = (int) ((this.screenSize.height / 2) - (2 * this.panCenterY));
        } else {
            tmpX = 0;
            tmpY = 0;
        }
        
        // draw the image
        if (map != null) {
            offScreenGraphics.drawImage(map,tmpX,tmpY,this);
        }
        
        // ...and the polygons
        GGDIndex.paint(offScreenGraphics);
        
        // ...and the OpMode result
        if (currentOpMode != null) {
            currentOpMode.paint(offScreenGraphics);
            
            // ...and the tooltip
            if (TRUE.equals(((String) this.opModePropertiesHash.get("KABOUM_USE_TOOLTIP")))) {
                GGDIndex.paintTooltip(offScreenGraphics, this.currentOpMode.mp);
            }
            
        }
        
        // And the busy Image
        if (busy == true && busyImg != null) {
            int x = screenSize.width/2 - busyImg.getWidth(this)/2;
            int y = screenSize.height/2 - busyImg.getHeight(this)/2;
            offScreenGraphics.drawImage(busyImg,x,y,this);
        }
        
        // Draw the image onto screen
        g.drawImage(offScreenImage, 0, 0, this);
        
        // Clear the buffer
        offScreenGraphics.clearRect(0,0,screenSize.width,screenSize.height);
    }
    
    
    /**
     *
     * Set the mouse pointer shape.
     * Possible values are: DEFAULT, CROSSHAIR, WAIT, MOVE.
     *
     * @param s Value
     *
     */
    public void setCursor(String s) {
        this.cursorValue = s;
        if (s.equals("DEFAULT"))
            this.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
        else if (s.equals("CROSSHAIR"))
            this.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));
        else if (s.equals("WAIT"))
            this.setCursor(new Cursor(Cursor.WAIT_CURSOR));
        else if (s.equals("MOVE"))
            this.setCursor(new Cursor(Cursor.MOVE_CURSOR));
        else if (s.equals("HAND"))
            this.setCursor(new Cursor(Cursor.HAND_CURSOR));
        else
            this.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    
    
    /**
     *
     * Write message into navigator status bar.
     *
     * @param message Message
     *
     */
    public void showMessage(String message) {
        this.showMessage(message, false);
    }
    
    
    /**
     *
     * Write message into navigator status bar.
     *
     * @param message Message
     *
     */
    public void showMessage(String message, boolean displaySurfaceAndPerimeter) {
        
        String surfString  = "";
        String periString  = "";
        
        // Surface
        if (displaySurfaceAndPerimeter) {
            
            if (this.activeGGD != null) {
                if (this.activeGGD.geometry != null) {
                    String surf = this.mapServerTools.pm.areaToString(this.activeGGD.geometry.getArea());
                    if (surf != null) {
                        surfString = " --- " + this.defaultLang.getString("STATUS_SURFACE") + surf + " " + this.mapServerTools.pm.sUnit;
                    }
                }
            } else if (this.currentSurface != -1) {
                surfString = " --- " + this.defaultLang.getString("STATUS_SURFACE") + this.mapServerTools.pm.areaToString(this.currentSurface) + " " + this.mapServerTools.pm.sUnit;
            }
            
            // Perimeter
            if (this.activeGGD != null) {
                if (this.activeGGD.geometry != null) {
                    String peri = this.mapServerTools.pm.perimeterToString(this.activeGGD.geometry.getPerimeter());
                    if (peri != null) {
                        periString = " --- " + this.defaultLang.getString("STATUS_PERIMETER") + peri + " m";
                    }
                }
            } else if (this.currentPerimeter != -1) {
                periString = " --- " + this.defaultLang.getString("STATUS_PERIMETER") + this.mapServerTools.pm.perimeterToString(this.currentPerimeter) + " m";
            }
            
            String tmpStr = this.defaultLang.getString("STATUS_SCALE") + " 1:"+this.mapServerTools.getScale() + " --- " + this.defaultLang.getString("STATUS_COORD") + message + periString + surfString;
            if (this.sendPositionCoordinatesToJS) {
                this.kaboumResult("COORDINATE_STRING|" + tmpStr);
            } else {
                this.showStatus(tmpStr);
            }
        }
        
        else {
            String tmpStr = this.defaultLang.getString("STATUS_SCALE") + " 1:"+this.mapServerTools.getScale() + " --- " + this.defaultLang.getString("STATUS_COORD") + message;
            if (this.sendPositionCoordinatesToJS) {
                this.kaboumResult("COORDINATE_STRING|" + tmpStr);
            } else {
                this.showStatus(tmpStr);
            }
        }
        
    }
    
    
    /**
     *
     * Overload getParameter(String) method
     *
     */
    public String getParameter(String s, String d) {
        
        String tmpStr = getParameter(s);
        
        if (tmpStr == null) {
            return d;
        }
        
        return tmpStr;
        
    }
    
    /**
     *
     * Refresh the tooltip display if request
     *
     */
    public void refreshTooltip() {
        if (TRUE.equals(this.opModePropertiesHash.get("KABOUM_USE_TOOLTIP"))) {
            this.repaint();
        }
    }
    
    /**
     * Method to create/load all parameters for geometric classes.
     * Default values are used if no value is provided for a given parameter
     *
     */
    private void loadGeoClassesParameters() {
        String inputAppletParameter = null;
        StringTokenizer st = null;
        
        // Display tooltips
        this.opModePropertiesHash.put("KABOUM_USE_TOOLTIP", getParameter("KABOUM_USE_TOOLTIP", FALSE));
        this.opModePropertiesHash.put("TOOLTIP_DISPLAY_PERIMETER", getParameter("TOOLTIP_DISPLAY_PERIMETER", FALSE));
        this.opModePropertiesHash.put("TOOLTIP_DISPLAY_AREA", getParameter("TOOLTIP_DISPLAY_AREA", FALSE));
        this.opModePropertiesHash.put("TOOLTIP_BOX_BORDER_SIZE", getParameter("TOOLTIP_BOX_BORDER_SIZE", "1"));
        this.opModePropertiesHash.put("TOOLTIP_BOX_BORDER_COLOR", getParameter("TOOLTIP_BOX_BORDER_COLOR", "black"));
        this.opModePropertiesHash.put("TOOLTIP_BOX_COLOR", getParameter("TOOLTIP_BOX_COLOR", "white"));
        this.opModePropertiesHash.put("TOOLTIP_TEXT_COLOR", getParameter("TOOLTIP_TEXT_COLOR", "black"));
        this.opModePropertiesHash.put("TOOLTIP_HORIZONTAL_MARGIN", getParameter("TOOLTIP_HORIZONTAL_MARGIN", "5"));
        this.opModePropertiesHash.put("TOOLTIP_VERTICAL_MARGIN", getParameter("TOOLTIP_VERTICAL_MARGIN", "5"));
        this.opModePropertiesHash.put("TOOLTIP_OFFSET", getParameter("TOOLTIP_OFFSET", "5"));
        
        // Font parameters
        this.opModePropertiesHash.put("KABOUM_FONT_NAME", getParameter("KABOUM_FONT_NAME", "Courier"));
        this.opModePropertiesHash.put("KABOUM_FONT_STYLE", getParameter("KABOUM_FONT_STYLE", "plain"));
        this.opModePropertiesHash.put("KABOUM_FONT_SIZE", getParameter("KABOUM_FONT_SIZE", "12"));
        
        // Roughness of geometrical objects
        this.opModePropertiesHash.put("GEOMETRY_ROUGHNESS", getParameter("GEOMETRY_ROUGHNESS", "1"));
        
        //
        // Folowing the DEFAULT display descriptor parameters.
        // Parameters from others display descriptor (except geoName
        // which must be unique) inherit from DEFAULT parameters
        // unless they are redefined
        //
        this.defaultDD = new KaboumGeometryDisplayDescriptor("DEFAULT",
                KaboumUtil.getColorParameter(getParameter("DEFAULT_DD_COLOR"), null),
                KaboumUtil.getColorParameter(getParameter("DEFAULT_DD_FILL_COLOR"), null),
                KaboumUtil.getColorParameter(getParameter("DEFAULT_DD_HILITE_COLOR"), null),
                KaboumUtil.getColorParameter(getParameter("DEFAULT_DD_SUPER_HILITE_COLOR"), null),
                KaboumUtil.getColorParameter(getParameter("DEFAULT_DD_MODIFIED_COLOR"), null),
                KaboumCoordinate.stoi(getParameter("DEFAULT_DD_POINT_TYPE")),
                KaboumUtil.stoi(getParameter("DEFAULT_DD_POINT_HEIGHT")),
                KaboumUtil.stoi(getParameter("DEFAULT_DD_POINT_WIDTH")),
                KaboumUtil.stoi(getParameter("DEFAULT_DD_LINE_WIDTH")),
                KaboumUtil.getColorParameter(getParameter("DEFAULT_DD_POINT_COLOR"), null),
                KaboumUtil.getColorParameter(getParameter("DEFAULT_DD_POINT_HILITE_COLOR"), null),
                readImage(this, KaboumUtil.toURL(getParameter("DEFAULT_DD_POINT_IMAGE"))),
                KaboumUtil.stob(getParameter("DEFAULT_DD_IS_FILLED"), false));
        
        this.geometryDDHash.put("DEFAULT", this.defaultDD);
        this.currentDD = this.defaultDD;
        
        //
        // Display descriptor class list
        // These classes inherit from DEFAULT class
        //
        inputAppletParameter = getParameter("DD_CLASS_LIST");
        
        if (inputAppletParameter != null) {
            
            // Variables definition
            KaboumGeometryDisplayDescriptor kaboumDisplayDescriptor;
            st = new StringTokenizer(inputAppletParameter, ",");
            
            // Awfull trick to avoid null st when only one
            // geometry is specified. In this case add a ","
            // at the end of the inputAppletParameter string
            if (st.countTokens() == 0) {
                String s = inputAppletParameter+",";
                st = new StringTokenizer(inputAppletParameter, ",");
            }
            
            // Loops over all defined class names
            while (st.hasMoreTokens()) {
                
                // Geometry Class name
                String geoName = st.nextToken();
                
                // Skip DEFAULT geometry if specified in the list
                if (geoName.equals("DEFAULT")) {
                    continue;
                }
                
                // Button type
                int geoPointType;
                if (getParameter(geoName+"_DD_POINT_TYPE") == null) {
                    geoPointType = this.defaultDD.getPointType();
                } else {
                    geoPointType = KaboumCoordinate.stoi(getParameter(geoName+"_DD_POINT_TYPE"));
                }
                
                // Object image path
                Image geoPointImage;
                if (getParameter(geoName+"_DD_POINT_IMAGE") == null) {
                    geoPointImage = this.defaultDD.getPointImage();
                } else {
                    geoPointImage = readImage(this, KaboumUtil.toURL(getParameter(geoName+"_DD_POINT_IMAGE")));
                }
                
                // Add this geometry class to the list of geometry classes
                kaboumDisplayDescriptor = new KaboumGeometryDisplayDescriptor(geoName,
                        KaboumUtil.getColorParameter(getParameter(geoName+"_DD_COLOR"), this.defaultDD.getColor()),
                        KaboumUtil.getColorParameter(getParameter(geoName+"_DD_FILL_COLOR"), this.defaultDD.getFillColor()),
                        KaboumUtil.getColorParameter(getParameter(geoName+"_DD_HILITE_COLOR"), this.defaultDD.getHiliteColor()),
                        KaboumUtil.getColorParameter(getParameter(geoName+"_DD_SUPER_HILITE_COLOR"), this.defaultDD.getHiliteColor()),
                        KaboumUtil.getColorParameter(getParameter(geoName+"_DD_MODIFIED_COLOR"), this.defaultDD.getModifiedColor()),
                        geoPointType,
                        KaboumUtil.stoi(getParameter(geoName+"_DD_POINT_HEIGHT"), this.defaultDD.getPointHeight()),
                        KaboumUtil.stoi(getParameter(geoName+"_DD_POINT_WIDTH"), this.defaultDD.getPointWidth()),
                        KaboumUtil.stoi(getParameter(geoName+"_DD_LINE_WIDTH"), this.defaultDD.getLineWidth()),
                        KaboumUtil.getColorParameter(getParameter(geoName+"_DD_POINT_COLOR"), this.defaultDD.getPointColor()),
                        KaboumUtil.getColorParameter(getParameter(geoName+"_DD_HILITE_COLOR"), this.defaultDD.getHiliteColor()),
                        geoPointImage,
                        KaboumUtil.stob(getParameter(geoName+"_DD_IS_FILLED"), this.defaultDD.getFilling()) );
                
                this.geometryDDHash.put(geoName, kaboumDisplayDescriptor);
            }
        }
        
        //
        // Folowing the DEFAULT geometry parameters.
        // Parameters from others geometry inherit from DEFAULT parameters
        // unless they are redefine
        //
        this.defaultPD = new KaboumGeometryPropertiesDescriptor("DEFAULT",
                KaboumUtil.stob(getParameter("DEFAULT_PD_IS_VISIBLE"), true),
                KaboumUtil.stob(getParameter("DEFAULT_PD_IS_COMPUTED"), false),
                KaboumUtil.stob(getParameter("DEFAULT_PD_IS_SURROUNDING"), false),
                KaboumUtil.stob(getParameter("DEFAULT_PD_IS_LOCKED"), false),
                KaboumUtil.stob(getParameter("DEFAULT_PD_VERTEX_SNAPPING"), false),
                KaboumUtil.stob(getParameter("DEFAULT_PD_EDGE_SNAPPING"), false));
        
        this.geometryPDHash.put("DEFAULT", this.defaultPD);
        this.currentPD = this.defaultPD;
        
        //
        // Properties class list
        // These classes inherit from DEFAULT properties class
        //
        inputAppletParameter = getParameter("PD_CLASS_LIST");
        
        if (inputAppletParameter != null) {
            
            // Variables definition
            KaboumGeometryPropertiesDescriptor kaboumObjectProperties;
            st = new StringTokenizer(inputAppletParameter, ",");
            
            // Awfull trick to avoid null st when only one
            // geometry is specified. In this case add a ","
            // at the end of the inputAppletParameter string
            if (st.countTokens() == 0) {
                String s = inputAppletParameter+",";
                st = new StringTokenizer(inputAppletParameter, ",");
            }
            
            // Loops over all geometries
            while (st.hasMoreTokens()) {
                
                // Properties class name
                String propName = st.nextToken();
                
                // Skip DEFAULT geometry if specified in the list
                if (propName.equals("DEFAULT")) {
                    continue;
                }
                
                kaboumObjectProperties = new KaboumGeometryPropertiesDescriptor(propName,
                        KaboumUtil.stob(getParameter(propName+"_PD_IS_VISIBLE"), this.defaultPD.isVisible()),
                        KaboumUtil.stob(getParameter(propName+"_PD_IS_COMPUTED"), this.defaultPD.isComputed()),
                        KaboumUtil.stob(getParameter(propName+"_PD_IS_SURROUNDING"), this.defaultPD.isSurrounding()),
                        KaboumUtil.stob(getParameter(propName+"_PD_IS_LOCKED"), this.defaultPD.isLocked()),
                        KaboumUtil.stob(getParameter(propName+"_PD_VERTEX_SNAPPING"), this.defaultPD.isVertexSnappable()),
                        KaboumUtil.stob(getParameter(propName+"_PD_EDGE_SNAPPING"), this.defaultPD.isEdgeSnappable()));
                
                this.geometryPDHash.put(propName, kaboumObjectProperties);
                
            }
        }
        
        
        // Active Display Descriptor
        inputAppletParameter = getParameter("GEOMETRY_ACTIVE_DD");
        if (inputAppletParameter != null) {
            this.currentDD = (KaboumGeometryDisplayDescriptor) this.geometryDDHash.get(inputAppletParameter);
            if (this.currentDD == null) {
                this.currentDD = this.defaultDD;
            }
        }
        
        // Active Properties
        inputAppletParameter = getParameter("GEOMETRY_ACTIVE_PD");
        if (inputAppletParameter != null) {
            this.currentPD = (KaboumGeometryPropertiesDescriptor) this.geometryPDHash.get(inputAppletParameter);
            if (this.currentPD == null) {
                
                this.currentPD = this.defaultPD;
            }
        }
        
        //
        // HEAVY DEBUGGING
        //
        if (KaboumUtil.getDebugMode()) {
            Enumeration e;
            for (e = this.geometryDDHash.elements(); e.hasMoreElements();) {
                KaboumUtil.debug(((KaboumGeometryDisplayDescriptor) e.nextElement()).toString());
            }
            for (e = this.geometryPDHash.elements(); e.hasMoreElements();) {
                KaboumUtil.debug(((KaboumGeometryPropertiesDescriptor) e.nextElement()).toString());
            }
        }
    }
    //////////////////////////////////////
    // Getters for some useful properties
    ///////////////////////////////////////
    
    /**
     * Returns the OpModeHash Hashtable
     * @returns the <code>OpModeHash</code> variable
     */
    public Hashtable getOpModeHash() {
        return this.opModeHash;
    }
    
    public void addMouseListener(MouseListener ml) {
        super.addMouseListener(ml);
        
    }
    
    public void removeMouseListener(MouseListener l) {
        super.removeMouseListener(l);
    }

    public KaboumPrecisionModel getPrecisionModel() {
        return this.pm;
    }

}


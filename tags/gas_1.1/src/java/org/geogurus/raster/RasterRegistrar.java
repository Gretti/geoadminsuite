/*
 * Copyright (C) 2003-2008  Gretti N'Guessan, Nicolas Ribot
 *
 * This file is part of GeoAdminSuite
 *
 * GeoAdminSuite is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GeoAdminSuite is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GeoAdminSuite.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.geogurus.raster;


import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.ResourceBundle;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.logging.Logger;

import org.geogurus.data.Extent;
import org.geogurus.tools.sql.ConPool2;
import org.geogurus.tools.string.ConversionUtilities;

import com.sun.media.jai.codec.FileSeekableStream;
import com.sun.media.jai.codec.TIFFDirectory;
import com.sun.media.jai.codec.TIFFField;

/**
 * This class registers .tif files into a geonline database.
 * The raster table must be present in the given database.
 * Usage: can be used either as a standalone program or as a class called in
 * another program.
 */
public class RasterRegistrar {
    protected transient Logger logger = Logger.getLogger(getClass().getName());
    
    protected static final String NEWLINE = System.getProperty("line.separator");
    /** the error message generated by this class */
    private String msg;
    /**
     * the name of the host running the postgres database.
     * Form is: host:port ex: terence:5432.
     * If port is omited, default value will be taken (5432)
     */
    private String dbhost;
    /** the port where to connect to database */
    private int dbport;
    /** The name of the database to register raster in: the raster table must
     *  be present in this database.
     */
    private String dbname;
    /** Login for DB */
    private String login;
    /** Password */
    private String password;
    /** the full path to the raster, as stored in the db */
    private String path;
    private String pathName;
    private String pathLabel;
    /** the geo attribute */
    private String geoName;
    /** the vector storing all raster filenames to register */
    private Vector files;
    /** tells if parameters are valid */
    private boolean paramValid;
    /** access to RasterRegistra resources with db infos and inits*/
    private ResourceBundle dbRes ;
    /** access to RasterRegistra resources */
    private ResourceBundle res ;
    
    /** Additional attributes to store */
    private ArrayList attributes;
    
    /** Empty constructor.
     * Creates a RasterRegistrar with default values given in resource file
     */
    public RasterRegistrar() {
        try {
            this.paramValid = true;
            this.files = new Vector();
            dbRes = ResourceBundle.getBundle("resources/RasterRegistrarDB") ;
            res = ResourceBundle.getBundle("resources/RasterRegistrar") ;
            dbhost = dbRes.getString("defaultDBHost");
            dbport = Integer.parseInt(dbRes.getString("defaultPortNumber"));
            dbname = dbRes.getString("defaultDBName");
            login = dbRes.getString("dbLogin");
            password = dbRes.getString("dbPwd");
            
            // Load attributes list
            attributes = new ArrayList();
            String attributeList = dbRes.getString("attributes");
            String[] attributeTab = ConversionUtilities.tokenize(attributeList);
            Attribute attribute;
            for (int i=0; i<attributeTab.length; i++) {
                String attr = attributeTab[i];
                String name = dbRes.getString(attr+".name");
                String type = dbRes.getString(attr+".type");
                String deft = dbRes.getString(attr+".default");
                if ((type.trim().equalsIgnoreCase("INT")) || (type.trim().equalsIgnoreCase("STRING"))) {
                    attribute = new Attribute();
                    attribute.name = name;
                    attribute.label = dbRes.getString(attr+".label");
                    attribute.type = type;
                    attribute.value = deft;
                    attributes.add(attribute);
                } else if ((type.trim().equalsIgnoreCase("WIDTH"))|| (type.trim().equalsIgnoreCase("HEIGTH"))) {
                    attribute = new Attribute();
                    attribute.name = name;
                    attribute.type = type;
                    attribute.value = deft;
                    attributes.add(attribute);
                } else if (type.trim().equalsIgnoreCase("DATE")) {
                    attribute = new Attribute();
                    attribute.name = name;
                    attribute.type = type;
                    attribute.label = dbRes.getString(attr+".label");
                    String frmt = dbRes.getString(attr+".format");
                    SimpleDateFormat df = new SimpleDateFormat(frmt);
                    if (deft.trim().equalsIgnoreCase("TODAY")) {
                        attribute.value =  df.format(Calendar.getInstance().getTime());
                    } else attribute.value = deft.trim();
                    attributes.add(attribute);
                } else if (type.trim().equalsIgnoreCase("GEO")) {
                    geoName = name;
                } else if (type.trim().equalsIgnoreCase("URL")) {
                    pathName = name;
                    path = deft;
                    pathLabel = dbRes.getString(attr+".label");
                }
            }
            msg = res.getString("UndefinedErrorMessage") ;
        } catch (Exception ex) {
            msg = res.getString("initFromResourceError") ;
            paramValid = false;
        }
    }
    
    
    // set/get methods
    public String getDbhost() {return this.dbhost;}
    public int getDbport() {return this.dbport;}
    public String getDbname() {return this.dbname;}
    public String getLogin() {return this.login;}
    public String getPassword() {return this.password;}
    public String getPath() {return this.path;}
    public String getPathLabel() {return this.pathLabel;}
    public ArrayList getAttributes() {return this.attributes;}
    
    public void setDbhost(String dbhost_) {dbhost = dbhost_;}
    public void setDbport(int dbport_) {dbport = dbport_;}
    public void setDbname(String dbname_) {dbname = dbname_;}
    public void setLogin(String login_) {login = login_;}
    public void setPassword(String password_) {password = password_;}
    public void setPath(String path_) {path = path_;}
    public void setAttributes(ArrayList attributes_) {attributes = attributes_;}
    public void setParamValid(boolean isValid) {paramValid = isValid;}
    public void clearFilesList() {files.clear();}
    
    
    /** Registering factory.
     * If params are OK, selects files to register and add to DB one by one.
     * @return Is registering process OK ?
     */
    public boolean register() {
        if (!paramValid) return false;      // parameters control
        if (!getFileList()) return false;   // file list
        // process for each file
        for (int i = 0; i < files.size()-1; i+=2)
            if (!registerIntoDB((String)files.elementAt(i), (String)files.elementAt(i+1))) return false;
        msg = res.getString("successMessage");
        return true;
    }
    
    
    /** populates the files vectors with all tfw/tif pairs found at path
     * only lower case tfw extension is allowed (as mapserver does not handle upper case)
     * tif extension can be tif or tiff, and lower/upper case
     * @return True if file list is loaded
     */
    protected boolean getFileList() {
        if (path==null) return false;
        File filepath = new File(path);
        String[] list = filepath.list();
        if (list == null) {
            // path is not a folder path
            msg = res.getString("pathError1") + path+ res.getString("pathError2");
            return false;
        }
        for (int i = 0; i < list.length; i++) {
            if (isValidExt(list[i])) files.addElement(list[i]);
        }
        // sorts the files to create tfw/tif pairs
        Object[] tmp_files = files.toArray();
        Arrays.sort(tmp_files);
        
        // check if pairs are correct, if so, fill the vector with them:
        // thus, skip missing pairs
        files.removeAllElements();
        
        for (int i = 0; i < tmp_files.length-1; i+=2) {
            String s1 = (String)tmp_files[i];
            String s2 = (String)tmp_files[i+1];
            if (s1.substring(0, s1.lastIndexOf(".")).equals(s2.substring(0, s2.lastIndexOf(".")))) {
                files.addElement(s1);
                files.addElement(s2);
            }
        }
        return true;
    }
    
    /**
     * Returns the extent of the given tif file
     *
     *@param fn the full filename of the tif file
     *@return the extent of the given tif file, or null if an error occured
     */
    public static Extent getTifExtent(String fn) {
        if (RasterRegistrar.isGeoTIFF(fn)) {
            return RasterRegistrar.getGeoTifExtent(fn);
        }
        
        // builds the tfw path:
        int idx = fn.lastIndexOf(".");
        String tfw = fn.substring(0, idx);
        
        if (!new File(tfw + ".tfw").exists()) {
            // look for a wld file
            if (new File(tfw + ".wld").exists()) {
                tfw += ".wld";
            } else {
                return null;
            }
        } else {
            tfw += ".tfw";
        }
        
        double llx = 0, lly = 0, urx = 0, ury = 0;
        int[] wh = RasterRegistrar.getTiffDimension(fn);
        // reading the tfw to compute raster extent
        try {
            BufferedReader in = new BufferedReader(new FileReader(tfw));
            String line = "";
            Vector lines = new Vector();
            
            // stores each tfw line in a vector, with double values
            while ((line = in.readLine()) != null) {
                try {
                    lines.addElement(new Double(line.trim()));
                } catch (NumberFormatException nfe) {
                    // not a number, maybe a comment, skip
                    nfe.printStackTrace();
                    continue;
                }
            }
            return new Extent(((Double)lines.elementAt(4)).doubleValue(),
            ((Double)lines.elementAt(5)).doubleValue() + (((Double)lines.elementAt(3)).doubleValue() * wh[1]),
            ((Double)lines.elementAt(4)).doubleValue() + (((Double)lines.elementAt(0)).doubleValue() * wh[0]),
            ((Double)lines.elementAt(5)).doubleValue());
        } catch (Exception ioe) {
            ioe.printStackTrace();
            return null;
        }
    }
    
    /**
     * Returns the extent of the given geoTIFF file
     *
     *@param fn the full filename of the geoTIFF file
     *@return the extent of the given tif file, or null if an error occured
     */
    public static Extent getGeoTifExtent(String fn) {
        TIFFField tf = null;
        double llx = 0, lly = 0, urx = 0, ury = 0;
        int[] wh = RasterRegistrar.getTiffDimension(fn);
       // some geotiff information
       // 6 entries in this parameter (I,J,K,X,Y,Z)
       double[] modelTiePoint = {0,0,0,0,0,0};
       // 3 entries in this parameter (scaleX, scaleY, scaleZ)
       double[] modelPixelScale = {0,0,0};
       
        try {
            FileSeekableStream ss = new FileSeekableStream(fn);
            TIFFDirectory td = new TIFFDirectory(ss, 0);
            
            if (td.isTagPresent(33922)) {
                modelTiePoint = td.getField(33922).getAsDoubles();
            }
            
            //modelPixelScaleTag
            if (td.isTagPresent(33550)) {
                modelPixelScale = td.getField(33550).getAsDoubles();
            }
            if (modelPixelScale == null || modelTiePoint == null) {
                // not a geoTIFF
                return null;
            }
            // computes the extent.
            // you should read  carefully geoTIFF specs for the following formulas.
            llx = modelTiePoint[3] - (modelTiePoint[0] * modelPixelScale[0]);
            lly = modelTiePoint[4] + ((modelTiePoint[1] - wh[1]) * modelPixelScale[1]);
            urx = llx + (wh[0] * modelPixelScale[0]);
            ury = lly + (wh[1] * modelPixelScale[1]);
            
            return new Extent(llx, lly, urx, ury);
        } catch (IOException ioe) {
            ioe.printStackTrace();
            return null;
        }
        
    }
    
    /**
     * Returns the extent of the given ecw file
     * For the moment, only ecw + ers files are supported, time for us to read header.
     * <br> Reads the ers file and search for 6 keywords:<br>
     * Xdimension, Ydimension: number of units per cell
     * NrOfCellsPerLine (represent the x-extension)
     * NrOfLines (represents the y-extension)
     * Eastings, Northings : upper left corner coordinates.<br>
     * easting + NrOfCellsPerLine = coordinate of upper right coord
     * Northings + NrOfLines = coordinate of coord.
     *
     *
     */
    public static Extent getEcwExtent(String fn) {
        // builds the ers path:
        int idx = fn.lastIndexOf(".");
        String tfw = fn.substring(0, idx);
        
        if (!new File(tfw + ".ers").exists()) {
            return null;
        }
        tfw += ".ers";
        
        double llx = 0, lly = 0, urx = 0, ury = 0;
        
        // reading the ers to compute raster extent
        try {
            BufferedReader in = new BufferedReader(new FileReader(tfw));
            String line = "";
            double eastings = 0, northings = 0, cellsperline = 1, lines = 1, xdim = 1, ydim = 1;
            StringTokenizer tk = null;
            String token = null;
            // parses file to extract valuable info: brute force, but...
            while ((line = in.readLine()) != null) {
                tk = new StringTokenizer(line, "=");
                int count = tk.countTokens();
                token = tk.nextToken().trim();
                
                if (count == 2) {
                    try {
                        if (token.equalsIgnoreCase("Xdimension")) {
                            xdim = new Double(tk.nextToken()).doubleValue();
                        } else if (token.equalsIgnoreCase("Ydimension")) {
                            ydim = new Double(tk.nextToken()).doubleValue();
                        } else if (token.equalsIgnoreCase("NrOfCellsPerLine")) {
                            cellsperline = new Double(tk.nextToken()).doubleValue();
                        } else if (token.equalsIgnoreCase("NrOfLines")) {
                            lines = new Double(tk.nextToken()).doubleValue();
                        } else if (token.equalsIgnoreCase("Northings")) {
                            northings = new Double(tk.nextToken()).doubleValue();
                        } else if (token.equalsIgnoreCase("Eastings")) {
                            eastings = new Double(tk.nextToken()).doubleValue();
                        }
                    } catch (NumberFormatException nfe) {
                        // not a number: error
                        return null;
                    }
                }
            }
            // builds the extent
            return new Extent(eastings, northings - (ydim * lines), eastings + (xdim * cellsperline), northings);
        } catch (Exception ioe) {
            ioe.printStackTrace();
            return null;
        }
    }
    
    /** Looks if the given file is a geotiff, by searching for specific GEOTIFF tag 
     *
     * @param fn The full path to the file.
     * @ return true if the file denoted by the given path is a GEOTIFF, false otherwise
     */
    public static boolean isGeoTIFF(String fn) {
        try {
            FileSeekableStream ss = new FileSeekableStream(fn);
            TIFFDirectory td = new TIFFDirectory(ss, 0);
            
            // GEOTIFF compulsory tag is 33550
            TIFFField tf = null;
            if (td.isTagPresent(33550)) {
                return true;
            }
        } catch (Exception ioe) {
            return false;
        }
        return false;
    }
    
    /**
     * Parses the tfw, construct a polygon representing its extent, and insert
     * into DB
     * @param tfw TWF file to parse
     * @param tif TIFF file to store
     * @return True if registry action is OK
     */
    protected boolean registerIntoDB(String tfw, String tif) {
        // parses given path: replaces "\" by "/"
        path = path.replace('\\', '/');
        path = path.lastIndexOf("/") != path.length() -1 ? path += "/" : path;
        
        // the name of raster (tif name without extension)
        String name = tif.substring(0, tif.lastIndexOf("."));
        String tmpVal = null;
        
        // the db query
        StringBuffer query = new StringBuffer("INSERT INTO ");
        query.append(dbRes.getString("rasterTableName"));
        Extent e = RasterRegistrar.getTifExtent(path + tif);
        
        // SRID
        String srid = "find_srid('" + this.dbname + "', '" + dbRes.getString("rasterTableName") + "', '"+geoName+"')";
        
        // construct the query to register the raster, based on the computed extent
        // and information given by user
        query.append("(").append(geoName);
        query.append(", ").append(pathName);
        for (int i=0; i<attributes.size(); i++) {
            Attribute att = (Attribute)(attributes.get(i));
            query.append(", ").append(att.name);
        }
        query.append(") ");
        query.append("values (GeometryFromText('POLYGON((");
        query.append(e.ll.x).append(" ").append(e.ll.y).append(",");
        query.append(e.ur.x).append(" ").append(e.ll.y).append(",");
        query.append(e.ur.x).append(" ").append(e.ur.y).append(",");
        query.append(e.ll.x).append(" ").append(e.ur.y).append(",");
        query.append(e.ll.x).append(" ").append(e.ll.y);
        query.append("))',"+srid+"),").append("'").append(path + tif).append("'");
        
        int[] wh = RasterRegistrar.getTiffDimension(path + tif);
        
        for (int i=0; i<attributes.size(); i++) {
            Attribute att = (Attribute)(attributes.get(i));
            if (att.type.equalsIgnoreCase("WIDTH")) att.value=Integer.toString(wh[0]);
            if (att.type.equalsIgnoreCase("HEIGTH")) att.value=Integer.toString(wh[1]);
            
            //
            // if default is "FILE" in a "DATE" type attribute, it
            // assumes that the acquisition date of the image is in the
            // name of the tif file (position separate by "_"):
            //          ndvi_code_yyyyMMdd.tif
            //
            // WARNING!!! Only the date string should have a lentgh of 8
            // characters since the code take the first 8 characters long
            // string as the acquisition date
            //
            // Added by jrom - 09 April 2002
            //
            tmpVal = att.value;
            
            // C'est pas propre !!!!
            if (att.name.equalsIgnoreCase("id_typimg_imglib")) {
                if (att.value.equalsIgnoreCase("-1")) {
                    StringTokenizer st = new StringTokenizer(name, "_");
                    String currentStr = st.nextToken();
                    if (currentStr.equalsIgnoreCase("ndvi")){
                        tmpVal = "5";
                    }
                    if (currentStr.equalsIgnoreCase("snr")){
                        tmpVal = "6";
                    }
                    if (currentStr.equalsIgnoreCase("snp")){
                        tmpVal = "7";
                    }
                }
            }
            
            if (att.type.equalsIgnoreCase("DATE")) {
                if (att.value.equalsIgnoreCase("FILE")) {
                    StringTokenizer st = new StringTokenizer(name, "_");
                    while(st.hasMoreTokens()) {
                        String currentStr = st.nextToken();
                        if (currentStr.length() == 8) {
                            tmpVal = currentStr;
                            break;
                        }
                    }
                }
            }
            
            else {
                //
                // Add on for Tallage
                // Ugly jrom
                //
                if (att.value.equalsIgnoreCase("FILE")) {
                    tmpVal = name;
                }
            }
            
            query.append(", ").append(tmpVal);
        }
        query.append(")");
        
        System.out.println("query sent: " + query.toString());
        // stores this query into DB
        try {
            //            Connection con = this.getConnection();
            ConPool2 conPool = ConPool2.getInstance();
            Connection con = conPool.getConnection(conPool.getConnectionURI(
                    dbhost, 
                    ""+dbport, 
                    dbname, 
                    login, 
                    password,
                    ConPool2.DBTYPE_POSTGRES));
            
            
            if (con == null) {
                msg = res.getString("connectionErrorMessage") + dbhost + ":" + dbname;
                return false;
            }
            Statement stmt = con.createStatement();
            stmt.executeUpdate(query.toString());
            stmt.close();
            con.close();
        } catch (SQLException sqle) {
            msg = sqle.getMessage();
            return false;
        }
        
        return true;
    }
    
    /**
     * Returns a int array with 2 values: the width and height of the given tiff
     * file
     */
    protected static int[] getTiffDimension(String tiffPath) {
        int[] res = {0,0};
        try {
            FileSeekableStream ss = new FileSeekableStream(tiffPath);
            TIFFDirectory td = new TIFFDirectory(ss, 0);
            
            // tiff width tag is 256, height is 257
            // super heavy tag management, according to tag type
            TIFFField tf = null;
            if (td.isTagPresent(256)) {
                tf = td.getField(256);
                switch (tf.getType()) {
                    case TIFFField.TIFF_SLONG:
                    case TIFFField.TIFF_BYTE:
                    case TIFFField.TIFF_SBYTE:
                    case TIFFField.TIFF_UNDEFINED:
                    case TIFFField.TIFF_SHORT:
                    case TIFFField.TIFF_SSHORT:
                        res[0] = tf.getAsInt(0);
                        break;
                    case TIFFField.TIFF_LONG:
                        res[0] = (int)tf.getAsLong(0);
                        break;
                }
            }
            if (td.isTagPresent(257)) {
                tf = td.getField(257);
                switch (tf.getType()) {
                    case TIFFField.TIFF_SLONG:
                    case TIFFField.TIFF_BYTE:
                    case TIFFField.TIFF_SBYTE:
                    case TIFFField.TIFF_UNDEFINED:
                    case TIFFField.TIFF_SHORT:
                    case TIFFField.TIFF_SSHORT:
                        res[1] = tf.getAsInt(0);
                        break;
                    case TIFFField.TIFF_LONG:
                        res[1] = (int)tf.getAsLong(0);
                        break;
                }
            }
            
            return res;
        } catch (Exception ioe) {
            ioe.printStackTrace();
            return res;
        }
    }
    /**
     * Returns true if the given string has an extension compatible with our rules:
     * .tfw or .tif or .TIF or .TIFF
     */
    protected boolean isValidExt(String fn) {
        int pt = fn.lastIndexOf(".");
        try {
            String ext = fn.substring(pt+1);
            return (ext.equals("tfw") || ext.equalsIgnoreCase("tif") || ext.equalsIgnoreCase("tiff"));
        } catch (IndexOutOfBoundsException e) {
            return false;
        }
    }
    
    
    /** returns the program's description
     */
    public String printHowTo() {
        StringBuffer m = new StringBuffer();
        try {
            int lineNumber = Integer.parseInt(res.getString("usageLength")) ;
            String line;
            for (int i=0; i<lineNumber; i++) {
                m.append(res.getString("usage."+i)).append(NEWLINE) ;
            }
        } catch (NumberFormatException nfe) {
            m.append("Can't read usage from resource file !") ;
        }
        return m.toString();
    }
    
    protected Connection getConnection() {
        java.sql.Connection conn= null;
        try {
            String dbURL="jdbc:postgresql://" + dbhost + ":" +dbport+ "/" + dbname;
            Class driver=Class.forName("org.postgresql.Driver");
            
            conn = DriverManager.getConnection(dbURL,login,password);
        } catch (ClassNotFoundException cnfe) {
            msg = "getConnnection: Cannot load driver for class name: org.postgresql.Driver\n";
            msg += cnfe.getMessage();
        } catch (SQLException sqle) {
        }
        return conn;
    }
    
    /** Returns the messages of the registry action.
     *
     * @return Action result (Error - Exception? - or OK!)
     */
    public String getMessage() {
        return this.msg;
    }
    
    public static void main(String[] args) {
        String f = "e:/geographic/utm.tif";
        System.out.println("is geotiff: " + RasterRegistrar.isGeoTIFF(f));
    }
}



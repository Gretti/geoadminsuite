package org.geogurus;

import java.util.*;
import java.io.*;
import org.geogurus.mapserver.MapFile;
import org.geogurus.mapserver.objects.Layer;
import org.geogurus.mapserver.objects.Map;
import org.geogurus.tools.sql.ConPool;
import java.sql.*;
import org.geogurus.tools.DataManager;
import org.geogurus.tools.LogEngine;
/**
 * Title:        geOnline Server classes
 * Description:  Set of Java classes to make the link between kaboum client and shape files / postgis DB containing geodata.
 * Copyright:    Copyright (c) 2002
 * Company:      SCOT
 * @author Niclas Ribot
 * @version 1.0
 */

 /**
  * Bean representing geographic information for a logged user
  * ie. with a valid session.
  * This bean is stored in session and used to generate a valid SIG page on the
  * client
  */
public class SIGUserParameters {
    /** the ERROR application mode (not really used)*/
    public static final int ERROR = 0;
    /** the creation application mode (only one object is expected in this mode)*/
    public static final int CREATION = 1;
    /** the modification application mode (only one object is expected in this mode)*/
    public static final int MODIFICATION = 2;
    /** the selection application mode (no object is expected in this mode:
    *  all objects for a theme should be retrieved, to allow user to select anyone)*/
    public static final int SELECTION = 3;
    /** the multiselection application mode (no object is expected in this mode:
    *  all objects for a theme should be retrieved, to allow user to select anyone)
    *  <br> not currently used*/
    public static final int MULTISELECTION = 4;
    /** the consultation application mode (only one object is expected in this mode)*/
    public static final int CONSULTATION = 5;
    /** To tell the request was processed by the ProcessQuery servlet: attributes could be discarded */
    public static final int PROCESSED = 6;
    /** the SUPPRESSION application mode (only one object is expected in this mode)*/
    public static final int SUPPRESSION = 7;

    /**
     * All geometries pertaining to this user.
     */
    protected Vector geometryClasses;

    /** the unique identifier for the user this bean belongs to */
    protected String userID;

    /** the unique DB identifier for the user's exploitation.
     *  Not really needed anymore ??
     */
    protected String exploitationID;
    /** the commune id for this user, used to generate the user mapfile */
    protected String communeID;
    /** the message generated by the server after a geometry processing
     *  Accessed by JSP pages
     */
    protected String serverMessage;
    protected String serverAction;

    /** The SIG title, set by the servlet according to the context */
    protected String mapTitle;

    /** the latest updated geometry on the server: after a successful creation, update
     *  or insert, this object is set to allow client application to redraw it.
     *  Accessed by JSP pages
     */
    protected Geometry updatedGeometry;

    /**
     * The full path to the mapFile generated for this user.
     * Used by JSP code to generate a valid html page.
     * the folder in which the mapfile will be put must be set in the properties files
     */
    protected String mapfilePath;
    
    /**
     * The complete MapFile object for this user
     */
    protected MapFile mapFile;

    /**
     * The template MapFile object for this user.
     */
    protected MapFile mapFileTemplate;
    
    /**
     * the vector of Layers added by the user
     */
    protected Vector mapServerBackgrounds;

    /**
     * The maximum area difference between declared and computed area for an object
     * Expressed in %. DO NOT PASS "10%" but "10"
     * A null value indicates no area control on the client
     * This value MUST be present in the properties file, under the
     * AREAERROR name.
     * If it is not present, no area control will be performed
     */
    protected String areaError;
    
    /**
     * The unit factor used to compute area when creating an object
     * Allows to pass from map units to "user-friendly" units.
     *Ex: map is in meter, but geo objects are more relevant in ha, 
     * areaUnitFactor is 10000 (1m2 / 10000 = 1ha
     * This value MUST be present in the properties file, under the
     * AREAERROR name.
     * If it is not present, no area control will be performed     
     */
    protected String areaUnitFactor;

    /**
     * The area unit for computation
     */
    protected int unit;

    /** the URL pointing to the background that should be displayed in the map instead
     *  of the default Mapserver layer.
     */
    protected String initialBackground;

    /** the current mode for the SIG part */
    protected int mode;

    /** the current mode, derived from mode but targeted to JSP pages: when
     *  the JSP page is called, this class has its mode set to "PROCESSED".
     *  jsMode contains the mode before the action was processed
     */
     protected String jsMode;

    /** the current extent for the user this bean belongs to */
    protected Extent extent;

    /** the URL to the SIG jsp page, used by servlet to redirect request on it*/
    protected String sigURL;

    /** the URL to redirect to when SIG processing is over */
    protected String returnURL;

    /** The error message generated by this class */
    protected String errorMessage;

/***********************************************************************
 ********* METHODS*************************************************
 ************************************************************************/

    public SIGUserParameters(String userID) {
        this.userID = userID;
        this.mapfilePath = null;
        areaError = null;
        mode = CREATION;
        geometryClasses = new Vector();
    }
    /**
     * generates the mapfile corresponding to this user, for the current context.
     * reads mapfile template, construct a mapfile object, and set user extent
     * If an existing fixed mapfile is provided, use it instead of template:
     * Set the mapfilepath to be this file, and uses userExtent to zoom on the
     * right place.
     * A custom extent can be set for this object before calling this method.
     * The mapfile will then contains this extent
     *@param layers a vector of Layers object to add to the user map.
     *              this could be used to add backgrounds dynamically.
     */
    public boolean generateMapFile(Vector layers) {
        // gets user extent only if this extent is not set.
        // this extent can be set manually to zoom on a particular area
        if (this.extent == null && !getUserExtent()) {
            // error message is generated by this method
            return false;
        }
        mapfilePath = DataManager.getProperty("FIXEDMAPFILE");

        if (mapfilePath != null) {
            // youpi, uses this fixed mapfile
            return true;
        }

        // Must retrieve the mapfile template from Application Properties to construct a
        // valid properties object containing mapfile values
        String mapfileTemplatePath= DataManager.getProperty("MAPFILETEMPLATE");

        if (mapfileTemplatePath == null) {
            //oops, no mapfile template provided in the configuration file.
            // cannot process a mapfile.
            errorMessage = "generateMapFile: cannot get the path for the template mapfile.\n<br>";
            errorMessage += "Verify the SIGKaboumListener properties file. It must contain a value for the MAPFILETEMPLATE parameter";
            return false;
        }

        // construct a MapFile Object
        if (mapFileTemplate == null) {
            mapFileTemplate = new MapFile(mapfileTemplatePath);
System.out.println("SIGUserParameters generateMapFile: loading template from: " + mapFileTemplate);            
        }
        // gets the extent.
        extent.toMapFileString();

        // generates the final mapfile:
        // full path, based on userid, which should be unique through the DB
        mapfilePath = DataManager.getProperty("MAPFILEPATH");
        mapfilePath += "user_" + userID + ".map";
        // add given layers to the template map file
        org.geogurus.mapserver.objects.Map templateMap = mapFileTemplate.load();
        if (templateMap == null) {
LogEngine.log("null template map, loading failed...");            
        }
        if (layers != null) {
            for (Iterator iter = layers.iterator(); iter.hasNext(); ) {
                Layer l = (Layer)iter.next();
                if (l.getName().equals("parcelles")) {
                    templateMap.addLayer(l, Map.TOP);
                } else {
                    templateMap.addLayer(l, Map.BOTTOM);
                }
            }
        }
        // writes the file on disk
        mapFile = new MapFile(mapfilePath);
        mapFile.save(templateMap);
System.out.println("SIGUserParameters generateMapFile: Saving map file:: " + mapfilePath);            

        return true;
    }

    /**
     * Sets this extent given a communeid in a localisation table
     * MUST change this mecanism to be more generic:
     * Parameters for commune table name, commune id column, and commune geo column should be
     * put in a ressource/properties file
     */
    protected boolean getUserExtent() {
        String communetable = DataManager.getProperty("USER_LOCALISATION_TABLE");
        String communepk = DataManager.getProperty("USER_LOCALISATION_PK");
        String communegeo = DataManager.getProperty("USER_LOCALISATION_GEO");

        if (communetable == null || communepk == null || communegeo == null) {
            // no value for this property: cannot write the map
            errorMessage = "getUserExtent: missing user localisation DB information.\n<br>";
            errorMessage += "Verify the SIGKaboumListener properties file. It must contain values for USER_LOCALISATION parameters";
            return false;
        }
        Connection con = null;
        try {
            con = ConPool.getConnection();
            StringBuffer query = new StringBuffer("select box3d(");
            query.append(communegeo).append(") from ").append(communetable);
            query.append(" where ").append(communepk).append("=").append(communeID);

LogEngine.log("getUserExtent: query: " + query.toString());
            Statement stmt = con.createStatement();
            ResultSet rs = stmt.executeQuery(query.toString());

            if (!rs.next()) {
                // no result: either bad DB objects, or bad id
                errorMessage = "getUserExtent: No result for the given id: " + communeID + ".\n<br>";
                return false;
            }
            // construct a new extent from the box3d string representation
            extent = new Extent(rs.getString(1));
            return true;

        } catch (SQLException sqle) {
            sqle.printStackTrace();
        } finally {
            try {con.close();} catch (SQLException s) {s.printStackTrace();}
        }
        return false;
    }

    public void addGeometryClass(GeometryClass g) {
        if (g != null) {
            this.geometryClasses.add(g);
        }
    }

    /**
     * returns the GeometryClass whose name is classname, or null if not found
     * maybe a hashtable for geometryClass to speed up retrieval ?
     */
    public GeometryClass getGeometryClass(String classname) {
        for (Iterator iter = geometryClasses.iterator(); iter.hasNext();) {
            GeometryClass gc = (GeometryClass)iter.next();

            if (gc.getName().equals(classname)) {
                return gc;
            }
        }
        return null;
    }
    /**
     * Quick and dirty method to remove a geometry
     */
    public void removeGeometry(String tableName, String objID) {
    }

    /**
     * Format available geometries into JS code. Method used only by JSP pages
     *
     * @param jsObject the name of the js toolbar Object on which the actionPerformed
     * is done.
     */
    public String getGeometriesAsJS(String jsObject) {
//System.out.println("getGeometriesAsJS: enter");
        StringBuffer buf = new StringBuffer();

        for (Iterator iter = geometryClasses.iterator(); iter.hasNext(); ) {
            buf.append(((GeometryClass)iter.next()).toKaboumString(jsObject));
            buf.append(System.getProperty("line.separator"));
        }

        return buf.toString();
    }

    /**
     * Returns the kaboum representation of this.updatedGeometry,
     * to allow client to redraw this geometry.
     * Accessed by JSP pages
     */
    public String getUpdatedGeometry() {
        if (this.updatedGeometry == null) {
            return "\"\"";
        }
        return "\"" + this.updatedGeometry.toKaboumString() + "\"";
    }

    /**
     * Returns a vector of MapServerLayers for all GeometryClass Objects of this class.
     * The GeometryClass must be elligible for display in mapfile: displayInMapserver boolean
     * The properties object must contains values for the intendeed layers:
     * layer_name.property=value
     */
    /*
    protected Vector getMapServerLayers(Properties props) {
        Vector res = new Vector();

        for (Iterator iter = geometryClasses.iterator(); iter.hasNext(); ) {
            GeometryClass gc = (GeometryClass)iter.next();

            if (gc.displayInMapserver) {
                Layer l = gc.getMSLayer();

                if (l == null) {
                    // no mslayer yet, construct it
                    l = new Layer();
                    l.setName(gc.name);
//                    l.load(props);
                // stores the mapserverLayer in the geometryClass directly for
                // later use, maybe
                    gc.setMapServerLayer(l);
                }
                res.add(l);
            }
        }
        return res;
    }
     */

    /**
     * Returns the list of all classes valid for this application. (got from geometryClass).
     * Each GeometryClass object can return its class name list: in case of creation/modification,
     * Also returns the list of properties classes: a mapping 1-1 is done between class list and
     * properties list. (We consider that each GeometryClass has its own properties.)
     * @param jsObject the javascript themeManager object's name on which the setAppletParameter
     * method will be applied.
     *
     */
    public String getKaboumClassList(String jsObject) {
        // gets the list of classes (will be the same for both OBJECT_CLASS_LIST
        // and PROPERTIES_CLASS_LIST.
        StringBuffer classList = new StringBuffer();
        // DisplayDescriptor class list is separated, as classes are not forced to have
        //a DD style.
        StringBuffer graphicClassList = new StringBuffer();

        for (int i = 0; i < geometryClasses.size(); i++) {
            GeometryClass gc = (GeometryClass)geometryClasses.elementAt(i);
            classList.append(gc.name);
            
            if (gc.isDDSet()) {
                // a graphic parameter for this class
                graphicClassList.append(gc.name);
            }
            if (i != geometryClasses.size() - 1) {
                classList.append(",");
                if (gc.isDDSet()) {
                   // a graphic parameter for this class
                    graphicClassList.append(",");
                }
            }
        }
        // now construct the 2 initialisation strings for kaboum
        StringBuffer buf = new StringBuffer(jsObject);
        buf.append(".setAppletParameter(\"MAIN\",\"OBJECT_CLASS_LIST\",");
        buf.append("\"").append(classList.toString()).append("\");");
        buf.append(System.getProperty("line.separator"));
        buf.append(jsObject).append(".setAppletParameter(\"MAIN\",\"PROPERTIES_CLASS_LIST\",");
        buf.append("\"").append(classList.toString()).append("\");");
        buf.append(System.getProperty("line.separator"));
        // added graphic class list
        buf.append(jsObject).append(".setAppletParameter(\"MAIN\",\"DD_CLASS_LIST\",");
        buf.append("\"").append(classList.toString()).append("\");");
        buf.append(System.getProperty("line.separator"));
        

        return buf.toString();
    }

    /**
     * Returns all the Kaboum Applet parameters for the current application
     * (class list, properties, etc.)
     * @param jsObject the javascript themeManager object's name on which the setAppletParameter
     * method will be applied.
     */
    public String getKaboumParameters(String jsObject) {
        StringBuffer buf = new StringBuffer();
        // the global properties for classes:
        buf.append(getKaboumClassList(jsObject));

        for (Iterator iter = geometryClasses.iterator(); iter.hasNext(); ) {
            buf.append(((GeometryClass)iter.next()).getKaboumParameters(jsObject));
        }
        return buf.toString();
    }

    /**
     * Returns the unique identifier for the object to edit in kaboum
     * This value will be used in the "K_NEW_OBJECT" kaboum parameters
     * If the mode is MODIFICATION (jsMode = EDITION|..."), then, the current
     *object id MUST NOT be set to an existing value, but to NEW instead.
     */
    public String getCurrentObjectID() {
        for (Iterator iter = geometryClasses.iterator(); iter.hasNext(); ) {
            GeometryClass g = (GeometryClass)iter.next();
            if (g.isActive && g.getEditedGeometryID() != null && jsMode.indexOf("EDITION|") == -1) {
                return g.getEditedGeometryID();
            }
        }
        return "NEW";
    }

    /**
     * Returns user extent as kaboum string (coma separated)
     */
    public String getKaboumExtent() {
        if (extent == null) {
            return "0,0,0,0";
        }
        return extent.toString();
    }

    /**
     * Return the current SIG mode as a Kaboum Keyword. This keyword
     * can be used in the html page to set the Kaboum mode (KaboumCommand).
     * In case of modification mode, the following command will be passed:
     * EDITION|<geom_class>|<geom_id> to allow default selection of geom whose id is
     * geom_id
     * NOTE: MUST MANAGE THE SELECTION MODE TO ALLOW OBJECTS TO BE PRESELECTED BY DEFAULT:
     * ALSO CHANGE GEOMETRYcLASS TO ALLOW PRESELECTED OBJECTS INITIALISATION
     */
    public String getJSMode() {
        if (jsMode.equals("EDITION|")) {
            // edition| = modification mode asked by client
            // search in all GeometryClasses if a editedGeometryID is set.
            // if so, construc the good kaboum command allowing this object to 
            // be default-selected
            for (Iterator iter = geometryClasses.iterator(); iter.hasNext(); ) {
                GeometryClass gc = (GeometryClass)iter.next();
                if (gc.getEditedGeometryID() != null) {
                    jsMode += gc.getName() + "|" + gc.getEditedGeometryID();
                }
            }
        }
        return jsMode;
    }
    
    /**
     * Adds the given layer to the vector of layers, used to add a custom layer to
     * the current mapfile
     */
    public void addMapServerBG(Layer l, byte order) {
        if (mapServerBackgrounds == null) {
            mapServerBackgrounds = new Vector(1);
        }
        mapServerBackgrounds.add(l);
    }
    
    /**
     * Returns the declared area of the edited geometry in the FIRST active GeometryClass
     * caution it should be one and only one active GeometryClass in this object.
     */
    public double getDeclaredArea() {
        for (Iterator iter = geometryClasses.iterator(); iter.hasNext(); ) {
            GeometryClass gc = (GeometryClass)iter.next();
            
            if (gc.isActive) {
                return gc.getDeclaredArea();
            }
        }
        return -1.0;
    }

    /** Returns the Area error tolerance 
     * If this property is already set by a calling program, takes this value.
     */
    public String getAreaError() { 
        if (areaError == null) {
            // get it from properties file. 
            areaError = DataManager.getProperty("AREAERROR");
        }
        return areaError; 
    }
    
    /** Return the Area error tolerance */
    public String getAreaUnitFactor() { 
        if (areaUnitFactor == null) {
            // get it from properties file. 
            areaUnitFactor = DataManager.getProperty("AREAUNIT");
        }
        return this.areaUnitFactor; 
    }
    ///////////////////////////////////////////////////////////
    // getXXX/setXXX basic methods
    //////////////////////////////////////////////////////////
    /** Returns the  mode. Compare it with class constants */
    public int getMode() { return mode; }
    /** return the servlet url to call back once transaction completed */
    public String getReturnURL() {return returnURL;}
    // public boolean getInitPhase() { return initPhase;}
    public Extent getExtent() { return extent;}
    public String getErrorMessage() {return this.errorMessage;}
    public Vector getGeometryClasses() {return this.geometryClasses;}
    /** return the userID */
    public String getUserID()        { return this.userID; }
    public String getCommuneID()        { return this.communeID; }
    public String getServerMessage() { return this.serverMessage; }
    public String getServerAction()  { return this.serverAction; }
    public String getMapTitle()      { return this.mapTitle; }
    public String getSIGURL()      { return this.sigURL; }
    public String getMapFilePath()      { return this.mapfilePath; }

    /*
     * Must set the jsMode now, as after servlet processing, the SIG mode will
     * be set to "processed" and thus not accessible to the HTML pages
     */
    public void setMode(int mode) {
LogEngine.log("setMode called: " + mode);
        this.mode = mode;

        if (mode == SIGUserParameters.PROCESSED ||
            mode == SIGUserParameters.ERROR) {
            return;
        }

        switch (mode) {
            case SIGUserParameters.CONSULTATION:
                jsMode =  "CONSULTATION";
                break;
            case SIGUserParameters.MODIFICATION:
                jsMode =  "EDITION|";
                break;
            case SIGUserParameters.CREATION:
                jsMode =  "EDITION";
                break;
            case SIGUserParameters.SELECTION:
                jsMode =  "SELECTION";
                break;
            case SIGUserParameters.MULTISELECTION:
                jsMode =  "MULTISELECTION";
                break;
            default:
                jsMode = "";
        }
LogEngine.log("...JSmode set to " + jsMode);        
    }

    public void setAreaError(String areaError) { this.areaError = areaError;}
    public void setAreaUnitFactor(String areaUnitFactor) { this.areaUnitFactor = areaUnitFactor;}
    public void setReturnURL(String returnURL) {this.returnURL = returnURL;}
    public void setUserID(String userID) {this.userID = userID;}
    public void setCommuneID(String cID) {this.communeID = cID;}
    public void setGeometryClasses(Vector geoms) {this.geometryClasses = geoms;}
    public void setUpdatedGeometry(Geometry geom) {this.updatedGeometry = geom;}
    public void setServerMessage(String serverMessage) {this.serverMessage = serverMessage;}
    public void setServerAction(String serverAction) {this.serverAction = serverAction;}
    public void setMapTitle (String mapTitle) { this.mapTitle = mapTitle;}
    public void setSIGURL (String su) { this.sigURL = su;}
    public void setExtent (Extent e) { this.extent = e;}
}